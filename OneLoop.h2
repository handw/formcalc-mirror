* OneLoop.h2
* contains most simplifications done in FORM 2
* this file is part of FormCalc
* last modified 27 Apr 00 th

* Note: this program runs only with the (commercial) version 2 of
* FORM. It should be much better than the FORM 1 code in OneLoop.h1.

.sort

s sqrt2, CW, SW, CW2, SW2;
s EL, Alfa, Alfa2, GS, Alfas, Alfas2;
cf abb, Mat, Eps, fme, sun, IndexDelta, DEN, pave;
cf SUNT, SUNTSum, SUNF;

.global

i J1, J2, J3, J4, C, IND1, IND2, IND3, IND4;
s M1, M2, M3, M4, M5, X1, X2;
v P1, P2, P3, P4;
f fc, ncm;
cf eq, neq, repl, PP, a0, b0, c0, d0, e0;
set oma: omp, omm;
set opa: omm, omp;
NT chp;
T QQ, dd, eps, pivot;


#procedure TrivialSubst()
id sqrt2^2 = 2;
id sqrt2^-2 = 1/2;
id CW^2 = CW2;
id CW^-2 = CW2^-1;
id SW^2 = SW2; 
id SW^-2 = SW2^-1;
id EL^2 = 4*Pi*Alfa;
id Alfa^2 = Alfa2;
id GS^2 = 4*Pi*Alfas;
id Alfas^2 = Alfas2;
#endprocedure


id a0(0) = 0;

#call TrivialSubst{}

#call Mandelstam{}


#if 'ExtFermions' == 1

b ga, omp, omm, Spinor;
.sort
keep brackets;

* Dirac algebra on open fermion chains

#procedure DiracOrder()
  repeat;
    id ga(C?, P1?) * ga(C?, P1?) = P1.P1;
    id ga(C?, J1?) * ga(C?, J1?) = d_(J1, J1);

    id,disorder, ga(C?, J1?) * ga(C?, J2?) =
      2*d_(J1, J2) - ga(C, J2) * ga(C, J1);
  endrepeat;
#endprocedure

#procedure DiracEquation()
  repeat;
    repeat;
      id ga(C?, P1?) * Spinor(P1?, M1?, X1?) = X1*M1 * Spinor(P1, M1, X1);

      id ga(C?, P1?) * ga(C?, J1?) * Spinor(P1?, M1?, X1?) =
        (2*d_(P1, J1) - X1*M1 * ga(C,J1)) * Spinor(P1, M1, X1);

      id ga(C?, P2?) * ga(C?, J1?) * pivot(C?, P1?, P2?) =
        (2*d_(P2, J1) - ga(C, J1) * ga(C, P2)) * pivot(C, P1, P2);
    endrepeat;

    repeat;
* since we deal with helicity ME, there's always an omp or omm after the
* left spinor, that's why the immediate "Spinor pslash" is commented out:
*      id Spinor(P1?, M1?, X1?) * ga(C?, P1?) = X1*M1 * Spinor(P1, M1, X1);

      id Spinor(P1?, M1?, X1?) * chp?oma?opa(C?) * ga(C?, P1?) =
        X1*M1 * Spinor(P1, M1, X1) * chp(C);

      id Spinor(P1?, M1?, X1?) * omp(C?) * ga(C?, J1?) * ga(C?, P1?) =
        Spinor(P1, M1, X1) *
          (2*d_(P1, J1) * omp(C) - X1*M1 * omm(C) * ga(C, J1));

      id Spinor(P1?, M1?, X1?) * omm(C?) * ga(C?, J1?) * ga(C?, P1?) =
        Spinor(P1, M1, X1) *
          (2*d_(P1, J1) * omm(C) - X1*M1 * omp(C) * ga(C, J1));

      id ga(C?, J2?) * ga(C?, P1?) * pivot(C?, P1?, P2?) =
        (2*d_(P1, J2) - ga(C, P1) * ga(C, J2)) * pivot(C, P1, P2);
    endrepeat;
#call DiracOrder{}
  endrepeat;
.sort
#endprocedure


repeat;
  id ga(C?, J1?) * chp?oma?opa(C?) = chp(C) * ga(C, J1);
  id omp(C?) * omm(C?) = 0;
  id omm(C?) * omp(C?) = 0;
  id omm(C?) * omm(C?) = omm(C);
  id omp(C?) * omp(C?) = omp(C);
endrepeat;
#call DiracOrder{}

id ga(C?, J1?) = fc(C, ga(C, J1));
id chp?oma(C?) = fc(C, chp(C));
repeat id fc(C?, X1?) * fc(C?, X2?) = fc(C, X1 * X2);
id fc(C?, chp?oma(C?)) = chp(C);
id Spinor(P1?, ?) * fc(C?, X1?) * Spinor(P2?, ??) =
  pivot(C, P1, P2) * Spinor(P1, .) * X1 * Spinor(P2, ..);
id fc(C?, X1?) = X1;

.sort

#call DiracSimplify{}
id chp?oma(C?) * Spinor(P2?, ?) * pivot(C?, P1?, P2?) =
  chp(C) * Spinor(P2, .);

#endif

.sort


* cancel q^2's in the numerator

repeat;
  if( match(q1.q1) );
    id,once, q1.q1 * b0(P1?, M1?, ?) =
      repl(q1 - P1) * a0(.) + M1*b0(P1, M1, .);
    id,once, q1.q1 * c0(P1?, P2?, M1?, ?) =
      repl(q1 - P1) * b0(P2 - P1, .) + M1*c0(P1, P2, M1, .);
    id,once, q1.q1 * d0(P1?, P2?, P3?, M1?, ?) =
      repl(q1 - P1) * c0(P2 - P1, P3 - P1, .) +
        M1*d0(P1, P2, P3, M1, .);
    id,once, q1.q1 * e0(P1?, P2?, P3?, P4?, M1?, ?) =
      repl(q1 - P1) * d0(P2 - P1, P3 - P1, P4 - P1, .) +
        M1*e0(P1, P2, P3, P4, M1, .);
    if( count(repl, 1) > 0 );
      id q1 = QQ(?);
      repeat id QQ(J1?) * repl(P1?) = d_(P1, J1) * repl(P1);
      id repl(?) = 1;
    endif;
  endif;
endrepeat;

ToTensor, QQ, q1;
id e_(J1?, J2?, J3?, J4?) = eps(J1, J2, J3, J4);

b QQ, a0, b0, c0, d0, e0, ga, eps;
.sort
keep brackets;


#if 'DIM' == 4
* add local terms for dimred/CDR

id QQ(J1?, J2?, J3?, J4?) * d0(?) = QQ(J1, J2, J3, J4) * d0(.) -
  5/144 * eq(e_(J1, J2, J3, J4)) * dd_(J1, J2, J3, J4) +
  1/8 * distrib_(1, 2, eq, neq, J1, J2, J3, J4);

id eq(J1?, J1?) = 1;
id neq(J1?, J1?) = 0;
id neq(J1?, J2?) = d_(J1, J2);

id QQ(J1?, J2?, J3?) * c0(P1?, P2?, ?) = QQ(J1, J2, J3) * c0(P1, P2, .) +
  1/36 * eq(e_(J1, J2, J3)) * (dd_(J1, J2, J3, P1) + dd_(J1, J2, J3, P2));

id eq(0) = 1;
id eq(?) = 0;

id QQ(J1?, J1?) * c0(?) = QQ(J1, J1) * c0(.) - 1/2;

id QQ(J1?, J1?) * b0(P1?, M1?, M2?) = a0(M2) + M1*b0(P1, M1, M2);

#endif


* decompose into Lorentz-covariant tensors

id QQ(??) = sum_(X1, 0, nargs_(..), 2,
  pave(0, 0)^(X1/2) * distrib_(1, X1, dd, QQ, ..));

id dd(?) = dd_(.);

id b0(P1?, ?) = PP(pave(1)*P1) * b0(P1, .);
id c0(P1?, P2?, ?) = PP(pave(1)*P1 + pave(2)*P2) * c0(P1, P2, .);
id d0(P1?, P2?, P3?, ?) =
  PP(pave(1)*P1 + pave(2)*P2 + pave(3)*P3) * d0(P1, P2, P3, .);
id e0(P1?, P2?, P3?, P4?, ?) =
  PP(pave(1)*P1 + pave(2)*P2 + pave(3)*P3 + pave(4)*P4) *
    e0(P1, P2, P3, P4, .);

repeat id PP(P1?) * QQ(J1?, ?) = d_(P1, J1) * QQ(.) * PP(P1);

id PP(?) = 1;
id QQ = 1;

if(count(pave, 1) == 0);
  symm b0 2, 3;
  id PP?{a0,b0,c0,d0,e0}(?) = pave(PP(0), .);
else;
  repeat id pave(?) * pave(??) = pave(., ..);
  id pave(??) * PP?{a0,b0,c0,d0,e0}(?) = pave(PP(..), .);
endif;


#if 'ExtFermions' == 1

b ga, omp, omm, Spinor, pivot, eps;
.sort
keep brackets;

#endif

id eps(J1?, J2?, J3?, J4?) = e_(J1, J2, J3, J4);

#if 'ExtFermions' == 1

* Dirac algebra on open fermion chains again

#call DiracOrder{}
#call DiracSimplify{}
id pivot(?) = 1;

#if 'DIM' == 4
* this is Chisholm's identity:
  repeat;
    id,once, ga(C?, J1?) * ga(C?, J2?) * ga(C?, J3?) =
      (omp(C) - omm(C)) * ga(C, J4) * e_(J1, J2, J3, J4) +
      d_(J1, J2) * ga(C, J3) -
      d_(J1, J3) * ga(C, J2) +
      d_(J2, J3) * ga(C, J1);
    sum J4;
  endrepeat;
  contract,0;
  repeat;
    id ga(C?, J1?) * chp?oma?opa(C?) = chp(C) * ga(C, J1);
    id omp(C?) * omm(C?) = 0;
    id omm(C?) * omp(C?) = 0;
    id omm(C?) * omm(C?) = omm(C);
    id omp(C?) * omp(C?) = omp(C);
  endrepeat;
#endif

id ga(C?, P1?) = fc(C, ga(P1));
#do i = 1, 4
  id,once, ga(C?, J1?) = fc(C, ga(IND'i')) * d_(J1, IND'i');
  id ga(C?, IND'i') = fc(C, ga(IND'i'));
  id d_(J1?, IND'i') = 1;
#enddo
#if 'VADecomp' == 1
  id omp(C?) = 1/2 + fc(C, ga5)/2;
  id omm(C?) = 1/2 - fc(C, ga5)/2;
#else
  id chp?oma(C?) = fc(C, chp);
#endif
repeat id fc(C?, ?) * fc(C?, ??) = fc(C, ., ..);

id e_(J1?, J2?, J3?, J4?{IND1,IND2,IND3,IND4}) =
  fme(Eps(J1, J2, J3, J4));
id Spinor(?) * fc(C?, ??) * Spinor(???) =
  fme(ncm(Spinor(.), .., Spinor(...)));
id Spinor(?) * Spinor(??) =
  fme(ncm(Spinor(.), Spinor(..)));
id fc(C?, ?) = fme(ncm(.));
repeat id fme(X1?) * fme(X2?) = fme(X1 * X2);

#endif

.sort


#call DotSimplify{}

#if 'DIM' == 0
* add local terms for dimreg

repeat;
  id,once, D*pave(a0(0), M1?) = 4*pave(a0(0), M1) - 2*M1;
  id,once, D*pave(b0(0), ?) = 4*pave(b0(0), .) - 2;
  id,once, D*pave(b0(1), ?) = 4*pave(b0(1), .) + 1;
  id,once, D*pave(b0(0,0), P1?, M1?, M2?) =
    4*pave(b0(0,0), P1, M1, M2) + P1.P1/6 - M1/2 - M2/2;
  id,once, D*pave(b0(1,1), ?) = 4*pave(b0(1,1), .) - 2/3;
  id,once, D*pave(c0(0,0), ?) = 4*pave(c0(0,0), .) - 1/2;
  id,once, D*pave(c0(0,0,1), ?) = 4*pave(c0(0,0,1), .) + 1/6;
  id,once, D*pave(c0(0,0,2), ?) = 4*pave(c0(0,0,2), .) + 1/6;
  id,once, D*pave(d0(0,0,0,0), ?) = 4*pave(d0(0,0,0,0), .) - 1/12;
endrepeat;
id D = 4;

#endif

#call Mandelstam{}


* the Mat(...) are kept at the almost-outermost level (only SumOver
* comes before), i.e. the amplitude is of the form Sum[c[i] Mat[i], i]
* -> need this for the calculation of the squared amplitude

id fme(X1?) = Mat(fme(X1));

* in contrast, abb(...) remain at the innermost level because they'll
* be abbreviated anyway.

id P1? . P2? = abb(P1 . P2);
id e_(J1?, J2?, J3?, J4?) = abb(e_(J1, J2, J3, J4));

repeat id abb(X1?) * abb(X2?) = abb(X1 * X2);

