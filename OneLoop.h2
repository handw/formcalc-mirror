* this is OneLoop.h2, the Form part of FormCalc
* last modified 8 Jul 99 th

* Note: this program runs only with the (commercial) version 2 of
* Form. It should be much better than the Form 1 code in pavered.h1.

.sort

s r2, CW, SW, C4, S4, C2, S2, EL, a2;
cf fme, IndexDelta, DEN, A0, B0m, B1m, B00m, B11m;
cf pave1, pave2, pave3, pave4, pave5;

.global

i J1, J2, J3, J4, C, IND1, IND2, IND3, IND4;
s M1, M2, M3, M4, M5, X1, X2;
v P1, P2, P3, P4;
f fc, ncm;
cf eq, neq, repl, PP, pid, a0, b0, c0, d0, e0;
set oma: omp, omm;
set opa: omm, omp;
NT chp;
T QQ, dd, eps, pivot;


#procedure TrivialSubst()
id r2^2 = 2;
id r2^-2 = 1/2;
id CW^-4 = C4;
id SW^-4 = S4;
id CW^-2 = C2;
id SW^-2 = S2;
id EL^4 = 16 * Pi^2 * a2;
#endprocedure


#call TrivialSubst{}

#call Mandelstam{}


#if 'ExtFermions' == 1

b ga, omp, omm, Spinor;
.sort
keep brackets;

* Dirac algebra on open fermion chains

#procedure DiracOrder()
  repeat;
    id ga(C?, P1?) * ga(C?, P1?) = P1.P1;
    id ga(C?, J1?) * ga(C?, J1?) = d_(J1, J1);
    id,disorder, ga(C?, J1?) * ga(C?, J2?) =
      2 * d_(J1, J2) - ga(C, J2) * ga(C, J1);
  endrepeat;
#endprocedure

#procedure DiracEquation()
  repeat;
    repeat;
      id ga(C?, P1?) * Spinor(P1?, M1?, X1?) = X1 * M1 * Spinor(P1, M1, X1);
      id ga(C?, P1?) * ga(C?, J1?) * Spinor(P1?, M1?, X1?) =
        (2 * d_(P1, J1) - X1 * M1 * ga(C, J1)) * Spinor(P1, M1, X1);
      id ga(C?, P2?) * ga(C?, J1?) * pivot(C?, P1?, P2?) =
        (2 * d_(P2, J1) - ga(C, J1) * ga(C, P2)) * pivot(C, P1, P2);
    endrepeat;
    repeat;
* since we deal with helicity ME, there's always an omp or omm after the
* left spinor, that's why the immediate "Spinor pslash" is commented out:
*      id Spinor(P1?, M1?, X1?) * ga(C?, P1?) = X1 * M1 * Spinor(P1, M1, X1);
      id Spinor(P1?, M1?, X1?) * chp?oma?opa(C?) * ga(C?, P1?) =
        X1 * M1 * Spinor(P1, M1, X1) * chp(C);
      id Spinor(P1?, M1?, X1?) * omp(C?) * ga(C?, J1?) * ga(C?, P1?) =
        Spinor(P1, M1, X1) *
          (2 * d_(P1, J1) * omp(C) - X1 * M1 * omm(C) * ga(C, J1));
      id Spinor(P1?, M1?, X1?) * omm(C?) * ga(C?, J1?) * ga(C?, P1?) =
        Spinor(P1, M1, X1) *
          (2 * d_(P1, J1) * omm(C) - X1 * M1 * omp(C) * ga(C, J1));
      id ga(C?, J2?) * ga(C?, P1?) * pivot(C?, P1?, P2?) =
        (2 * d_(P1, J2) - ga(C, P1) * ga(C, J2)) * pivot(C, P1, P2);
    endrepeat;
#call DiracOrder{}
  endrepeat;
.sort
#endprocedure


repeat;
  id ga(C?, J1?) * chp?oma?opa(C?) = chp(C) * ga(C, J1);
  id omp(C?) * omm(C?) = 0;
  id omm(C?) * omp(C?) = 0;
  id omm(C?) * omm(C?) = omm(C);
  id omp(C?) * omp(C?) = omp(C);
endrepeat;
#call DiracOrder{}

id ga(C?, J1?) = fc(C, ga(C, J1));
id chp?oma(C?) = fc(C, chp(C));
repeat id fc(C?, X1?) * fc(C?, X2?) = fc(C, X1 * X2);
id fc(C?, chp?oma(C?)) = chp(C);
id Spinor(P1?, ?) * fc(C?, X1?) * Spinor(P2?, ??) =
  pivot(C, P1, P2) * Spinor(P1, .) * X1 * Spinor(P2, ..);
id fc(C?, X1?) = X1;

.sort

#call DiracSimplify{}
id chp?oma(C?) * Spinor(P2?, ?) * pivot(C?, P1?, P2?) =
  chp(C) * Spinor(P2, .);

#endif

.sort


* cancel q^2's in the numerator

repeat;
  if( match(q1.q1) );
    id,once, q1.q1 * b0(P1?, M1?, ?) =
      repl(q1 - P1) * a0(.) + M1 * b0(P1, M1, .);
    id,once, q1.q1 * c0(P1?, P2?, M1?, ?) =
      repl(q1 - P1) * b0(P2 - P1, .) + M1 * c0(P1, P2, M1, .);
    id,once, q1.q1 * d0(P1?, P2?, P3?, M1?, ?) =
      repl(q1 - P1) * c0(P2 - P1, P3 - P1, .) +
        M1 * d0(P1, P2, P3, M1, .);
    id,once, q1.q1 * e0(P1?, P2?, P3?, P4?, M1?, ?) =
      repl(q1 - P1) * d0(P2 - P1, P3 - P1, P4 - P1, .) +
        M1 * e0(P1, P2, P3, P4, M1, .);
    if( count(repl, 1) > 0 );
      id q1 = QQ(?);
      repeat id QQ(J1?) * repl(P1?) = d_(P1, J1) * repl(P1);
      id repl(?) = 1;
    endif;
  endif;
endrepeat;

ToTensor, QQ, q1;
id e_(J1?, J2?, J3?, J4?) = eps(J1, J2, J3, J4);

b QQ, a0, b0, c0, d0, e0, ga, eps;
.sort
keep brackets;


#if 'DIM' == 4
* add local terms for dimred/CDR

id QQ(J1?, J2?, J3?, J4?) * d0(?) = QQ(J1, J2, J3, J4) * d0(.) -
  5/144 * eq(e_(J1, J2, J3, J4)) * dd_(J1, J2, J3, J4) +
  1/8 * distrib_(1, 2, eq, neq, J1, J2, J3, J4);

id eq(J1?, J1?) = 1;
id neq(J1?, J1?) = 0;
id neq(J1?, J2?) = d_(J1, J2);

id QQ(J1?, J2?, J3?) * c0(P1?, P2?, ?) = QQ(J1, J2, J3) * c0(P1, P2, .) +
  1/36 * eq(e_(J1, J2, J3)) * (dd_(J1, J2, J3, P1) + dd_(J1, J2, J3, P2));

id eq(0) = 1;
id eq(?) = 0;

id QQ(J1?, J1?) * c0(?) = QQ(J1, J1) * c0(.) - 1/2;

id QQ(J1?, J1?) * b0(P1?, M1?, M2?) = a0(M2) + M1 * b0(P1, M1, M2);

#endif


* decompose into Lorentz-covariant tensors

id QQ(??) = sum_(X1, 0, nargs_(..), 2,
  pid(0, 0)^(X1/2) * distrib_(1, X1, dd, QQ, ..));

id dd(?) = dd_(.);

id b0(P1?, ?) = PP(pid(1) * P1) * b0(P1, .);
id c0(P1?, P2?, ?) = PP(pid(1) * P1 + pid(2) * P2) * c0(P1, P2, .);
id d0(P1?, P2?, P3?, ?) =
  PP(pid(1) * P1 + pid(2) * P2 + pid(3) * P3) * d0(P1, P2, P3, .);
id e0(P1?, P2?, P3?, P4?, ?) =
  PP(pid(1) * P1 + pid(2) * P2 + pid(3) * P3 + pid(4) * P4) *
    e0(P1, P2, P3, P4, .);

repeat id PP(P1?) * QQ(J1?, ?) = d_(P1, J1) * QQ(.) * PP(P1);

id PP(?) = 1;
id QQ = 1;

repeat id pid(?) * pid(??) = pid(., ..);
id pid(?) * PP?{a0,b0,c0,d0,e0}?{pave1,pave2,pave3,pave4,pave5}(??) =
  PP(., ..);
id PP?{c0,d0,e0}?{pave3,pave4,pave5}(??) = PP(0, ..);

id a0(0) = 0;
id a0(M1?) = A0(M1);

symm b0 2, 3;
id b0(?) = B0m(.);
id pave2(1, P1?, M1?, M2?) = B1m(P1, M1, M2);
id pave2(0, 0, P1?, M1?, M2?) = B00m(P1, M1, M2);
id pave2(1, 1, P1?, M1?, M2?) = B11m(P1, M1, M2);


#if 'ExtFermions' == 1

b ga, omp, omm, Spinor, pivot, eps;
.sort
keep brackets;

#endif

id eps(J1?, J2?, J3?, J4?) = e_(J1, J2, J3, J4);

#if 'ExtFermions' == 1

* Dirac algebra on open fermion chains again

#call DiracOrder{}
#call DiracSimplify{}
id pivot(?) = 1;

#if 'DIM' == 4
* this is Chisholm's identity:
  repeat;
    id,once, ga(C?, J1?) * ga(C?, J2?) * ga(C?, J3?) =
      (omp(C) - omm(C)) * ga(C, J4) * e_(J1, J2, J3, J4) +
      d_(J1, J2) * ga(C, J3) -
      d_(J1, J3) * ga(C, J2) +
      d_(J2, J3) * ga(C, J1);
    sum J4;
  endrepeat;
  contract,0;
  repeat;
    id ga(C?, J1?) * chp?oma?opa(C?) = chp(C) * ga(C, J1);
    id omp(C?) * omm(C?) = 0;
    id omm(C?) * omp(C?) = 0;
    id omm(C?) * omm(C?) = omm(C);
    id omp(C?) * omp(C?) = omp(C);
  endrepeat;
#endif

id ga(C?, P1?) = fc(C, ga(P1));
#do i = 1, 4
  id,once, ga(C?, J1?) = fc(C, ga(IND'i')) * d_(J1, IND'i');
  id ga(C?, IND'i') = fc(C, ga(IND'i'));
#enddo
id e_(J1?, J2?, J3?, J4?{IND1,IND2,IND3,IND4}) =
  fme(e_(J1, J2, J3, J4));
#if 'VADecomp' == 1
  id omp(C?) = 1/2 + fc(C, ga5)/2;
  id omm(C?) = 1/2 - fc(C, ga5)/2;
#else
  id chp?oma(C?) = fc(C, chp);
#endif
repeat id fc(C?, ?) * fc(C?, ??) = fc(C, ., ..);
id Spinor(?) * fc(C?, ??) * Spinor(???) =
  fme(ncm(Spinor(.), .., Spinor(...)));
id Spinor(?) * Spinor(??) =
  fme(ncm(Spinor(.), Spinor(..)));
id fc(C?, ?) = fme(ncm(.));
repeat id fme(X1?) * fme(X2?) = fme(X1 * X2);

#endif

.sort


#call DotSimplify{}

#if 'DIM' == 0
* add local terms for dimreg

repeat;
  id,once, D * A0(M1?) = 4 * A0(M1) - 2 * M1;
  id,once, D * B0m(?) = 4 * B0m(.) - 2;
  id,once, D * B11m(?) = 4 * B11m(.) - 2/3;
  id,once, D * B1m(?) = 4 * B1m(.) + 1;
  id,once, D * B00m(P1?, M1?, M2?) =
    4 * B00m(P1, M1, M2) + 1/6 * P1.P1 - 1/2 * M1 - 1/2 * M2;
  id,once, D * pave3(0, 0, P1?, P2?, M1?, M2?, M3?) =
    4 * pave3(0, 0, P1, P2, M1, M2, M3) - 1/2;
  id,once, D * pave3(0, 0, J1?, P1?, P2?, M1?, M2?, M3?) =
    4 * pave3(0, 0, J1, P1, P2, M1, M2, M3) + 1/6;
  id,once, D * pave4(0, 0, 0, 0, P1?, P2?, P3?, M1?, M2?, M3?, M4?) =
    4 * pave4(0, 0, 0, 0, P1, P2, P3, M1, M2, M3, M4) - 1/12;
endrepeat;
id D = 4;

#endif

#call Mandelstam{}

