(*
	NumPrep.m
		prepares Fortran code from FormCalc output
		last modified 28 Oct 99 th

NumPrep is a program for generating Fortran code out of FormCalc output.
It has been tested only for 2 -> 2 processes.

The philosophy behind NumPrep is that the user should NOT HAVE TO MODIFY
the code after NumPrep did its job since that is typically the point
where most bugs creep in. NumPrep thus produces all modules of code, the
necessary include files, and a Makefile.

*)


Print[""];
Print["NumPrep 1.5"];
Print["by Thomas Hahn"];
Print["last revision: 28 Oct 99"];


NumPrep`$NumPrepDir =
  If[ FileType[$Input] === File, $Input,
        (* or, if NumPrep was loaded from a directory in $Path: *)
    Block[ {full},
      Scan[
        If[ FileType[full = # <> "/" <> $Input] === File, Return[full] ]&,
        $Path ] ]
  ];
Block[ {pos = StringPosition[NumPrep`$NumPrepDir, "/"]},
  NumPrep`$NumPrepDir = If[ Length[pos] === 0, ".",
    StringTake[ NumPrep`$NumPrepDir, pos[[-1, -1]] ] ];
];
	(* expand relative paths *)
NumPrep`$NumPrepDir = SetDirectory[NumPrep`$NumPrepDir] <> "/";
ResetDirectory[]


BeginPackage["Parameters`"]

Get[NumPrep`$NumPrepDir <> "para.m"]

EndPackage[]


BeginPackage["NumPrep`"]

MakeCode::usage = "MakeCode[indir, outdir, mask] is the main function of
NumPrep. It takes two mandatory arguments: fromdir points to a directory
containing the input files, and outdir to the directory where the Fortran
files are put. mask is an optional parameter (default value *.m) which
specifies a mask to select the input files."

AbbrFile::usage = "AbbrFile is an option of MakeCode and specifies the
file in which the abbreviations were saved."

MatFile::usage = "MatFile is an option of MakeCode and specifies the file
in which the helicity matrix elements were saved (for processes with
external fermions)."

BornMask::usage = "BornMask is an option of MakeCode. It singles out the
code modules which contain Born amplitudes."

RenConst::usage = "RenConst is an option of MakeCode. It tells MakeCode
how the file containing the renormalization constants is called."

Drivers::usage = "Drivers points to a directory containing customised
versions of the driver programs for running the generated Fortran code.
This directory need not contain all driver programs: files not contained
therein are taken from the default directory, " <> $NumPrepDir <>
"drivers."

Abb::usage = "Abb[i] denotes the ith abbreviation introduced by FormCalc."

AbbSum::usage = "AbbSum[i] denotes the ith sum of abbreviations introduced
by FormCalc."

F::usage = "F[i] denotes the ith fermion matrix element introduced by
FormCalc."

Mat::usage = "Mat[Fi, Fj] is the helicity matrix element composed of the
fermion chains Fi and Fj."

Ctree::usage = "Ctree[Fi] is the coefficient of Fi of the tree-level
amplitude."

Cloop::usage = "Cloop[Fi] is the coefficient of Fi of the one-loop
amplitude."

$NumPrepDir::usage = "$NumPrepDir is the path where NumPrep and its
companion files are located."

$GenerateCodeFor::usage = "$GenerateCodeFor specifies the platform for
which Fortran code is produced. This affects only the calling sequence for
the Fortran compiler, and is closely connected with the $F77 variable. If
you want the code to be produced always for the same architecture on which
NumPrep is running on, put $GenerateCodeFor = $SystemID."

$ExtraLibs::usage = "$ExtraLibs specifies additional libraries needed for
linking the final executable. By default, this is the CERNlib."

$LoopToolsDir::usage = "$LoopToolsDir is the path where the include files
for LoopTools are located."

$RenConstDir::usage = "$RenConstDir is the path where the Fortran files 
for calculating the renormalization constants is located."

$BlockSize::usage = "$BlockSize gives the maximum LeafCount a Fortran
expression generated by NumPrep may have. Any expression with LeafCount >
$BlockSize will be chopped up before being written to the Fortran file. To
stay strictly within ANSI Fortran limits, $BlockSize would have to be
ridiculously low, say 100, but most Fortran compilers allow much larger
expressions."

$FileSize::usage = "$FileSize gives the maximum LeafCount the expressions
in a single Fortran file may have. If the expressions grow larger than
$FileSize, the file is split into several pieces."

$F77::usage = "$F77 specifies the command line for the Fortran compiler."

$IntArgFuncs = "$IntArgFuncs is a list of functions (typically Fortran
arrays) whose arguments must be integers."

dconjg::usage = "dconjg[x] is the complex conjugate of x in Fortran.
MakeCode replaces all Conjugate by dconjg."

Cval::usage = "Cval is the array containing the three-point integrals in
Fortran."

Dval::usage = "Dval is the array containing the four-point integrals in
Fortran."

SumOver::usage = "SumOver[i, r] indicates that the amplitude with which it
is multiplied is to be summed in the index i over the range r."


(* declare some FormCalc symbols and the fermion masses: *)

PrependTo[$ContextPath, "Parameters`"]

{ A0, B0, B1, B00, B11, DB0, DB1, DB00, DB11,
  C0i, Cget, D0i, Dget, IndexDelta, Pair, Eps,
  DEN, S, T, U, e, k, s, Hel, Scale,
  Trivial, MatTrivial }


Begin["`Private`"]

AppendTo[$ContextPath, "Parameters`"]

$NumberMarks = False

Off[CopyFile::filex]


DEN[p_, m_] := (p - m)^-1

SumOver[index_, range_] := (
  IndexRange[index] = range;
  AppendTo[Indices[oname], index];
  1
)


NN[x_] := N[x, 35] /. 0 -> 0.

Num[expr_] := NN[expr] /. {1. -> 1, -1. -> -1} /.
  rc:$IntArgFuncs[__] :> (rc /. r_Real :> Floor[r])


ToFortran[s_String] = s

ToFortran[s_] := ToString[FortranForm[s]]


ToSymbol[x__] := ToExpression[ StringJoin[ToString/@ Flatten[{x}]] ]


k[n_Integer] = n

s[n_Integer] := 2 + 3 n		(* the longitudinal polarization vector *)

e[n_Integer] := e[n] = ToSymbol["i", n]

Hel[n_Integer] := Hel[n] = ToSymbol["i", n]


(* convert FormCalc's abbreviations (symbols) to arrays which are easier
   to handle in Fortran: *)

ToArray[s_Symbol] :=
Block[ {c = Characters[ToString[s]], h},
  {h, c} = ToExpression[StringJoin[#]]&/@
    {Select[c, LetterQ], Select[c, DigitQ]};
  ubound[h] = Max[ubound[h], c];
  s = h[c]
]

ToArray[s_] = s


ubound[_] = 0


Unprotect[Max]

Max[s_[i_Integer], s_[j_Integer]] := s[Max[i, j]]

Protect[Max]


ToList[a_Max] := List@@ a

ToList[a_List] = a

ToList[a_] = {a}


MatType[h_[i_], h_[j_]] := MatType[h][i, j]

MatType[h_] := MatType[h] = ToSymbol["Mat", h]

MatTrivial[__] = 1

Mat[0] = 0


A0[0] = 0


(* CodeBlocks partitions an expression such that each part has a
   LeafCount less than $FileSize. *)

CodeBlocks[h_][a_, b_, r___] :=
  CodeBlocks[h][{a, b}, r] /; LeafCount[{a, b}] < $FileSize

CodeBlocks[h_][a_, r___] := cb[ h@@ Flatten[{a}], CodeBlocks[h][r] ]

CodeBlocks[_][] = Sequence[]


(* Chunks writes "var = expr" to file handle hh in blocks whose
   LeafCount is <= $BlockSize. Expressions longer than $BlockSize
   are written as
	var = part1
	var = var + part2
	...				*)

Chunks[var_, expr_] :=
Block[ {theexpr = expr, ini},
  ini[_Ctree | _Cloop] = True;		(* always add to these *)
  If[ LeafCount[expr] > $BlockSize,
    If[ Head[expr] === Plus,
      theexpr = List@@ expr /. Plus -> PlusChop;
      ChopUp[var, Plus@@ theexpr];
      Return[] ];
    theexpr = expr /. Plus -> PlusChop
  ];
  WriteAssign[var, theexpr];
]


PlusChop[expr__] := ChopUp[Unique["tmp"], Plus[expr]] /;
  LeafCount[{expr}] > $BlockSize

PlusChop[expr__] := Plus[expr]

ChopUp[var_, expr_] :=
Block[ {$FileSize = $BlockSize},
  Scan[WriteAssign[var, #]&, Flatten[Operate[CodeBlocks, expr]]];
  var
]


WriteAssign[var_, expr_] :=
Block[ {as, v = ToFortran[var]},
  as = "\t" <> v <> " = ";
  If[ ini[var] =!= True, ini[var] = True,
    as = as <> v <>
      If[StringTake[ToFortran[expr], 1] === "-",
        "\n     -  ",
        " +\n     -  "] ];
  WriteString[hh, as];
  Write[hh, expr];
  newline
]


r8cmd = "!" <> $NumPrepDir <> "r8_" <> Environment["HOSTTYPE"] <> " > "

OpenWriteFortran[file_] := OpenWrite[ r8cmd <> outdir <> file <> ".F",
  FormatType -> FortranForm, PageWidth -> 67 ]


(*
   FormCalc-generated code is written out in five parts:

				     |	handled by NumPrep-function
   ----------------------------------|--------------------------------
   1. the code modules		     |	WriteCode (-> WriteCodeModule)
   2. the variable declarations      |	WriteVars (-> WriteVarDecl)
   3. the abbreviations		     |	WriteAbbr (-> WriteAbbrModule)
   4. the makefile		     |	MakeCode
   5. the control file		     |	MakeCode (-> WriteSubroutine)
   6. copy the driver files          |  MakeCode
*)


TakeVar[v_ -> _] = v

TakeVar[v_] = v


WriteVars[_[], _, _] = {}

WriteVars[vars_, type_, common_] :=
Block[ {v, p},
  v = Select[TakeVar/@ vars, StringTake[ToString[#], 1] =!= "t" &];
  p = Position[v, _[_Symbol..], 1, Heads -> False];
  WriteVarDecl["\n\t" <> type, MapAt[IndexRange/@ # &, v, p]];
  p = Position[v, _[__], 1, Heads -> False];
  WriteVarDecl["\n\tcommon " <> common, MapAt[Head, v, p]];
  WriteString[hh, "\n"];
]

WriteVarDecl[_, _[]] = {}

WriteVarDecl[decl_, vars_] :=
Block[ {llen = Infinity, dl = StringLength[decl], l, s},
  WriteString[hh,
    Fold[
      ( l = StringLength[s = ToFortran[#2]];
        {#1, If[(llen += l + 2) > 64, llen = dl + l; decl, ", "], s} )&,
		(* 64 = 70 - 8 for the tab + 1 for \t + 1 for \n *)
      "",
      vars ]//StringJoin]
]


(* OrderAbbr orders the abbreviations such that the definition of
   each abbreviation comes before its first use. This is necessary
   because the calculation of fermionic matrix elements may have
   introduced new abbreviations which of course must be computed
   before the fermionic ME. *)

IndependentQ[{_, _Real, _}, _] = True;
IndependentQ[_, {_, _Real, _}] = False;
IndependentQ[_, _] = True

Affected["A"] = Affected["t"] = True;	(* select Abb*, tmp* *)
Affected[_] = False

OrderAbbr[abbr_] :=
Block[ {a2, as, l, i = 1},
  a2 = Select[abbr, Affected[StringTake[#[[1]]//ToString, 1]]&];
  as = MapIndexed[Join[List@@ #1, #2]&, a2];
  l = Length[as];
  Block[#,
    Scan[(# = Random[])&, Complement[#, First/@ a2]];
    as = Sort[as, IndependentQ];
    While[i < l,
      If[ !NumberQ[#], # = Random[]; as = as ]&[ as[[i, 1]] ];
      If[ NumberQ[ as[[i, 2]] ], ++i, as = Sort[as, IndependentQ] ]
    ]
  ]&[Cases[a2, _Symbol, {-1}]//Union];
  Join[ 
    Select[abbr, !Affected[StringTake[#[[1]]//ToString, 1]]&],
    a2[[Last/@ as]] ]
]


WriteAbbr[_, _, _[]] = {}

WriteAbbr[abbr_, oname_] :=
Block[ {ab, do, onamex, mod = {}},
  do[_] = {};
  AppendTo[ do[Evaluate[Cases[#[[1]], _Symbol]]], # ]&/@ abbr;
  ab = Cases[ DownValues[do],
    _[_[_[ind_List]], a_] :> doloop[ind, a] ];
  If[ LeafCount[ab] > $FileSize,
    MapIndexed[
      ( onamex = oname <> FromCharacterCode[#2[[1]] + 96];
        WriteAbbrModule[#1, onamex] )&,
      Flatten[Operate[CodeBlocks, ab]]],
  (* else *)
    WriteAbbrModule[ab, oname] ];
  mod
]

WriteAbbrModule[abbr_, oname_] :=
Block[ {hh},
  AppendTo[mod, oname];
  Print["writing ", oname, ".F"];
  hh = OpenWriteFortran[oname];
  WriteString[hh, "\tsubroutine " <> oname <> "\n"];
  WriteDecl[
    {Pair, Eps, A0, B0, DB0, B1, DB1, B00, DB00, B11, DB11},
    {Cget, Dget}, abbr];
  Scan[WriteDef, abbr];
  WriteString[hh, "\tend\n"];
  Close[hh]
]


WriteDecl[_, _, 0] = WriteDecl[_, _, _[]] = {}

WriteDecl[cext_, iext_, expr_] :=
Block[ {ce, ie},
  WriteString[hh,
    "\timplicit logical (a-s,u-z)\n" <>
    "\timplicit double complex (t)\n" <>
    "#include \"vars.h\""];
  ce = Select[cext, !FreeQ[expr, #]&];
  ie = Select[iext, !FreeQ[expr, #]&];
  WriteVarDecl["\n\tdouble complex ", ce];
  WriteVarDecl["\n\tinteger ", ie];
  WriteVarDecl["\n\texternal ", Join[ce, ie]];
  WriteString[hh, "\n\n"]
]


doloop[_[], _[abbr__]] = abbr

WriteDef[doloop[ind_, abbr_]] :=
  WriteDoLoop[Apply[Chunks, abbr, 1], ind]

WriteDef[abbr_] := Chunks@@ abbr


Attributes[WriteDoLoop] = {HoldFirst}

WriteDoLoop[cmd_, _[]] := cmd

WriteDoLoop[cmd_, ind_] := (
  WriteString[hh, "\n"];
  Scan[WriteString[hh, "\tdo ", #, " = 1, ", IndexRange[#], "\n"]&, ind];
  cmd;
  WriteString[hh, StringJoin[Table["\tenddo\n", {Length[ind]}]] ];
)


pave = A0 | B0 | B1 | B00 | B11 | DB0 | DB1 | DB00 | DB11 | C0i | D0i

WriteCode[file_] :=
Block[ {oname, onamex, amp, newline, coeffh},
  oname = StringReplace[file, ".m" -> ""];
  amp = Num[Get[indir <> file]] /. bca:pave[__] :> abr[bca];
  coeffh = If[ StringMatchQ[oname, bornmask],
    amp = amp /. unusedtree -> 0; Ctree,
    amp = amp /. unusedloop -> 0; Cloop ];

  newline := WriteString[hh, "\n"];
  If[LeafCount[amp] > $FileSize && Head[amp] === Plus,
    MapIndexed[
      ( onamex = oname <> FromCharacterCode[#2[[1]] + 96];
        Indices[onamex] = Indices[oname];
        WriteCodeModule[#1, onamex] )&,
      Flatten[Operate[CodeBlocks, amp]]],
  (* else *)
    WriteCodeModule[amp, oname] ]
]

WriteCodeModule[amp_, oname_] :=
Block[ {hh},
  AppendTo[codemod, oname];
  Print["writing ", oname, ".F"];
  hh = OpenWriteFortran[oname];
  WriteString[hh, "\
#include \"defs.h\"\n\n\
\tsubroutine " <> oname <> "\n"];
  WriteDecl[{Pair, Eps}, {IndexDelta}, amp];

  maxmat[coeffh] = Fold[ Max,
    maxmat[coeffh],
    Apply[(Chunks[Level[#1, {-1}, coeffh], #2]; #1)&,
      MapAt[coefflist, Flatten[{amp} /. Mat -> ToCoeff], -1], 1]
  ];

  WriteString[hh, "\tend\n"];
  Close[hh]
]


	(* note: ToCoeff assumes that ordering occurs in the same
	   way for coefficients and matrix elements *)
ToCoeff[s_] := coeff[{s} /. Times -> Sequence]


coeff/: coeff[n_] x_ := coeff[n, x]

coeff/: coeff[n_, x_] + r_ := {coeff[n, x], r}

coefflist[c_coeff] = c

coefflist[c_] := coeff[{Trivial[1]}, c]


abr[ C0i[i_, args__] ] :=
Block[ {uu = Unique["iint"], ind},
  ind = Select[Indices[oname], !FreeQ[{args}, #]&];
  If[ Length[ind] =!= 0, uu = uu@@ ind ];
  ibca = {ibca, uu -> Num[Cget[args]]};
  abr[C0i[id_, args]] = Cval[id, uu];
  Cval[i, uu]
]

abr[ D0i[i_, args__] ] :=
Block[ {uu = Unique["iint"], ind},
  ind = Select[Indices[oname], !FreeQ[{args}, #]&];
  If[ Length[ind] =!= 0, uu = uu@@ ind ];
  ibca = {ibca, uu -> Num[Dget[args]]};
  abr[D0i[id_, args]] = Dval[id, uu];
  Dval[i, uu]
]

abr[ func_ ] :=
Block[ {uu = Unique["cint"], ind},
  ind = Select[Indices[oname], !FreeQ[func, #]&];
  If[ Length[ind] =!= 0, uu = uu@@ ind ];
  cbca = {cbca, uu -> func};
  abr[func] = uu
]


	(* LoopComponents gives back e.g.
		1. {F[4], SUN[3]}
		2. {F[i1], SUN[i2]}
		3. Ctree[4, 3]
		4. Ctree[i1, i2]
		5. "\tdo i1 = 1, 4\n\tdo i2 = 1, 3\n"
		6. "\tenddo\n\tenddo\n"			*)
LoopComponents[arr_] :=
Block[ {n, vars, vdo},
  n = ToList[maxmat[arr]];
  vars = If[ #[[1]] === 1, 1, Unique["j"] ]&/@ n;
  vdo = DeleteCases[Thread[vars -> Level[n, {-1}]], 1 -> _];
  { n,
    MapThread[Head[#1][#2]&, {n, vars}],
    Level[n, {-1}, arr],
    arr@@ vars,
    Apply[
      "\tdo " <> ToString[#1] <> " = 1, " <> ToString[#2] <> "\n" &,
      vdo, 1 ]//StringJoin,
    Table["\tenddo\n", {Length[vdo]}]//StringJoin }
]


WriteSubroutine[name_, {sub_}] :=
  WriteString[hh, "\n#define " <> name <> " " <> sub <> "\n"]

WriteSubroutine[name_, tocall_] :=
  WriteString[hh, "\n\tsubroutine " <> name <>
    ({"\n\tcall ", #}&)/@ tocall <> "\n\tend\n"]


GetFile[file_] := Flatten[Get/@ file]


Options[MakeCode] = {
  AbbrFile -> "abbr",
  MatFile -> "mat*",
  BornMask -> "born*",
  RenConst -> "rcsm_dimD.F",
  Drivers -> "drivers"
}

MakeCode[idir_, odir_, mask_String:"*.m", opt___Rule] :=
Block[ {abbr, mat, bornmask, rconst, drivers,
indir, outdir, files, oname, hh, n,
nonzero, unusedtree, unusedloop, maxmat, matmem, ntree, nloop,
cbca, ibca, cstore, dstore, Indices,
codemod, abbrmod, bcamod, bca2mod,
Conjugate = dconjg},

  {abbr, mat, bornmask, rconst, drivers} =
    {AbbrFile, MatFile, BornMask, RenConst, Drivers} /.
    {opt} /. Options[MakeCode];

  outdir = SetDirectory[odir] <> "/";
  ResetDirectory[];

  indir = SetDirectory[idir] <> "/";
  mat = FileNames[mat];
  abbr = FileNames[abbr];
  files = Complement[
    FileNames[Flatten[{mask, bornmask <> ".m"}]],
    abbr, mat ];
  mat = GetFile[mat] /. m_Mat :> ToArray/@ m;
  abbr = Select[GetFile[abbr], AtomQ[ #[[1]] ]&]//OrderAbbr;
  ResetDirectory[];

  nonzero = First/@ DeleteCases[mat, _ -> 0];
  unusedtree = Alternatives@@
    Select[ Union[#[[1, 2]]&/@ mat], FreeQ[nonzero, Mat[_, #]]& ];
  unusedloop = Alternatives@@
    Select[ Union[#[[1, 1]]&/@ mat], FreeQ[nonzero, Mat[#, _]]& ];
  maxmat[_] = {};
  mat = Num[mat];

(* Part 1: the code modules *)

  codemod = cbca = ibca = Indices[_] = {};
  Scan[WriteCode, files];

(* Part 2: the variable declarations *)

  ibca = Flatten[ibca];
  cbca = Flatten[cbca];
  dstore = Plus@@ Cases[ibca, (v_ -> _Dget) :>
    Times@@ IndexRange/@ Cases[v, _Symbol]];
  cstore = Plus@@ Cases[ibca, (v_ -> _Cget) :>
    Times@@ IndexRange/@ Cases[v, _Symbol]];
	(* now take into account:
	   a) each D0i invokes 4 C0i's
	   b) integration is done separately for the left and right
	      hemisphere; also, sampling takes place in two halves due
	      to the Gauss algorithm, so altogether we need 4 times the
	      number of integrals as for the differential cross-section. *)
  cstore = ToString[4 (cstore + 4 dstore) + 1];
  dstore = ToString[4 dstore + 1];

  Print["writing vars.h"];
  hh = OpenWrite[outdir <> "vars.h"];
  WriteString[hh, "\
#include \"kin.h\"\n\
#include \"rcsm.h\"\n\n\
\tdouble complex Cval(13, " <> cstore <> ")\n\
\tcommon /cpave/ Cval\n\n\
\tdouble complex Dval(46, " <> dstore <> ")\n\
\tcommon /dpave/ Dval\n"];

  WriteVars[
    If[ FreeQ[abbr, Scale], abbr,
      WriteString[hh,
        "\n\tdouble precision Scale\n\tcommon /abbrvar/ Scale\n"];
      DeleteCases[abbr, Scale -> _] ],
    "double complex ", "/abbrvar/ "];

  WriteVars[cbca, "double complex ", "/bcavar/ "];
  WriteVars[ibca, "integer ", "/bcavar/ "];
  WriteVars[#[[1, 1, 1]]&/@ DownValues[IndexRange],
    "integer ", "/indices/ "];

  ntree = LoopComponents[Ctree];
  nloop = LoopComponents[Cloop];
  n = MapThread[MatType,
    {ToList[Max[ ntree[[1]], nloop[[1]] ]], ntree[[1]]}];
  WriteVars[
    {ntree[[3]], nloop[[3]], DeleteCases[n, 1]}//Flatten,
    "double complex ", "/coeff/ " ];

  Close[hh];

(* Part 3: the abbreviations *)

  abbrmod = WriteAbbr[Join[abbr, mat /. Mat -> MatType], "abbr"];

  cbca = Join[cbca, ibca];
  bcamod = WriteAbbr[Select[cbca, FreeQ[#, T | U]&], "bca"];
  bca2mod = WriteAbbr[Select[cbca, !FreeQ[#, T | U]&], "bca2"];

(* Part 4: the makefile *)

  Print["writing GNUmakefile"];
  hh = OpenWrite[outdir <> "GNUmakefile"];
  WriteString[hh, "\
LTDIR = " <> $LoopToolsDir <> "\n\
LIBS = -L$(LTDIR)$(HOSTTYPE) -lff\n\
EXTRALIBS = " <> $ExtraLibs <> "\n\
FC = " <> $F77 <> " -I. -I$(LTDIR)include -g\n\
OBJS =" <> ({" \\\n ", #, ".o"}&)/@
             Join[abbrmod, bcamod, bca2mod, codemod] <> "\n\n\
default: run\n\n\
renconst.o: " <> rconst <> " kin.h\n\
\t$(FC) -c -o $@ $<\n\n\
$(OBJS): %.o: %.F kin.h vars.h\n\
\t$(FC) -c $<\n\n\
clean:\n\
\trm -f *.o\n\n\
%: %.F num.F $(LTDIR)include/tools.F\
 kin.h process.h feyn.F $(OBJS) renconst.o\n\
\t$(FC) -o $@ $< renconst.o $(OBJS) $(LIBS) $(EXTRALIBS)\n\n"];
  Close[hh];

(* Part 5: the control file feyn.F *)

  Print["writing feyn.F"];
  hh = OpenWriteFortran["feyn"];
  WriteString[hh, "\
*#define LAMBDA 1D10\n\
*#define MUDIM 1D10\n\n\
#define CSTORE " <> cstore <> "\n\
#define DSTORE " <> dstore <> "\n" <>
    (If[ NumberQ[ n = NN[ToExpression[#]] ],
       {"#define ", #, " ", ToFortran[n], "\n"}, {} ]&)/@
      Names["Parameters`*"] <>
    "\n"];

  WriteSubroutine["calc_abbr", abbrmod];
  WriteSubroutine["calc_bca", bcamod];
  WriteSubroutine["calc_bca2", bca2mod];

  ntree2 = LoopComponents[Ctree];

  WriteString[hh, "\n\n\
\tsubroutine calc_amp\n\
\timplicit integer (j)\n\
\timplicit logical (a-i,k-z)\n\
\tdouble complex c, m\n\
#include \"vars.h\"\n\n\
" <> ntree[[5]] <> "\
\t" <> ToFortran[ ntree[[4]] ] <> " = dcmplx(0D0)\n\
" <> ntree[[6]] <> "\n\
" <> nloop[[5]] <> "\
\t" <> ToFortran[ nloop[[4]] ] <> " = dcmplx(0D0)\n\
" <> nloop[[6]] <> "\n"];

  sums[_] = {};
  Scan[AppendTo[sums[Indices[#]], #]&, codemod];
  Cases[ DownValues[sums], (_[_[ind_List]] :> prc_) :>
    WriteDoLoop[
      WriteString[hh, StringJoin[{"\tcall ", #, "\n"}&/@ prc]], ind ]
  ];

  WriteString[hh, "\n\
" <> ntree2[[5]] <> "\
\tc = dconjg(" <> ToFortran[ ntree2[[4]] ] <> ")\n\n\
\tm = dcmplx(0D0)\n\
" <> ntree[[5]] <> "\
\tm = m + " <>
  ToFortran[ ntree[[4]] *
    Inner[MatType, ntree[[2]], ntree2[[2]], Times] ] <> "\n\
" <> ntree[[6]] <> "\
\ttreeamp = treeamp + dble(c*m)\n\n\
\tm = dcmplx(0D0)\n\
" <> nloop[[5]] <> "\
\tm = m + " <>
  ToFortran[ nloop[[4]] *
    Inner[MatType, nloop[[2]], ntree2[[2]], Times] ] <> "\n\
" <> nloop[[6]] <> "\
\tloopamp = loopamp + 2D0*dble(c*m)\n\
" <> ntree2[[6]] <> "\n\
\tend\n"];

  Close[hh];

(* Part 6: copy the driver files *)

  files = {};

  If[ FileType[drivers] === Directory,
    SetDirectory[drivers];
    CopyFile[#, outdir <> #]&/@ (files = FileNames[]);
    ResetDirectory[]
  ];

  SetDirectory[$NumPrepDir <> "drivers"];
  CopyFile[#, outdir <> #]&/@ Complement[FileNames[], files];
  ResetDirectory[];

  SetDirectory[$RenConstDir];
  CopyFile[#, outdir <> #]&/@ FileNames[{rconst, "*.h"}];
  ResetDirectory[];
]

End[]


$F77::undef = "Warning: I don't know the correct f77 compiler switches for
your system. I'll use f2c and proceed with fingers crossed. If I run into
problems, please update NumPrep.m."

(* IMPORTANT: you must choose here the correct compiler flags for your
   Fortran compiler, *in particular* (= at least) one to make the
   compiler disregard the stubborn 72-characters-per-line limit of
   Fortran. Practically all compilers have such a flag, only
   unfortunately, the naming of this flag varies widely across different
   computer systems.

   Choices for some systems are listed below in the $F77 = ... line. If
   you don't find your system among them, please look up the appropriate
   options in your f77 man page and insert them there. *)

$F77 := $F77 = Switch[ $GenerateCodeFor,
  "DEC-AXP", "f77 -O -extend_source -warn truncated_source",
  "HP-RISC", "fort77 -O2 +es +U77",
  "Solaris", "f77 -e",
  "PGF77",   "pgf77 -O2 -Mextend -g77libs",
  "Linux",   $NumPrepDir <> "f77c -O -f",
  _,         Message[f77::undef]; $NumPrepDir <> "f77c -O -f" ]

$GenerateCodeFor = "DEC-AXP"

$ExtraLibs = "-L$(CERN)/$(CERN_LEVEL)/lib -lpdflib -lmathlib -lpacklib"

$BlockSize = 700

$FileSize = 30 $BlockSize

$LoopToolsDir = HomeDirectory[] <> "/LoopTools/"

$RenConstDir = $NumPrepDir <> "rconst/fortran/"

	(* these functions must always have integer arguments *)
$IntArgFuncs = F | SUN | dZfL1 | dZfR1 | dMf1 | Af |
  MSf | MSf2 | MCha | MCha2 | MNeu | MNeu2 |
  USf | USfC | UCha | UChaC | VCha | VChaC | ZNeu | ZNeuC


EndPackage[]

