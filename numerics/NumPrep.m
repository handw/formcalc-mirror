(*
	NumPrep.m
		prepares Fortran code from FormCalc output
		last modified 24 Jun 99 th

NumPrep is a program for generating Fortran code out of FormCalc output.
It has been tested only for 2 -> 2 processes.

The philosophy behind NumPrep is that the user should NOT HAVE TO MODIFY
the code after NumPrep did its job since that is typically the point where
most bugs creep in. NumPrep thus produces all modules of code, the
necessary include files, and a Makefile.

In order for this to work, NumPrep assumes some intelligence on the side
of the user: In particular, that the diagrams were split into groups (e.g.
self energies, vertices, boxes), and that the files are reasonably named.

*)


Print[""];
Print["NumPrep 1.4"];
Print["by Thomas Hahn"];
Print["last revision: 24 Jun 99"];


NumPrep`$NumPrepDir =
  If[ FileType[$Input] === File, $Input,
        (* or, if NumPrep was loaded from a directory in $Path: *)
    Block[ {full},
      Scan[
        If[ FileType[full = # <> "/" <> $Input] === File, Return[full] ]&,
        $Path ] ]
  ];
Block[ {pos = StringPosition[NumPrep`$NumPrepDir, "/"]},
  NumPrep`$NumPrepDir = If[ Length[pos] === 0, ".",
    StringTake[ NumPrep`$NumPrepDir, pos[[-1, -1]] ] ];
];
	(* expand relative paths *)
NumPrep`$NumPrepDir = SetDirectory[NumPrep`$NumPrepDir] <> "/";
ResetDirectory[]


BeginPackage["Parameters`"]

Get[NumPrep`$NumPrepDir <> "para.m"]

EndPackage[]


BeginPackage["NumPrep`"]

MakeCode::usage = "MakeCode[indir, outdir, mask] is the main function of
NumPrep. It takes two mandatory arguments: fromdir points to a directory
containing the input files, and outdir to the directory where the Fortran
files are put. mask is an optional parameter (default value *.m) which
specifies a mask to apply to find the input files."

Resonance::usage = "Resonance is an option of MakeCode. If set to True,
MakeCode treats the Higgs resonance. Further options which influence this
are Dyson and ModifyingFunction."

ModifyingFunction::usage = "ModifyingFunction is an option of MakeCode. It
specifies an additional multiplicative factor - e.g. MH^2/S - used in
applying the pole scheme when treating the Higgs resonance. See also the
options Resonance and Dyson."

Dyson::usage = "Dyson is an option of MakeCode and specifies whether the
Higgs resonance should be treated using Dyson resummation of the self
energies. See also the options Resonance and ModifyingFunction."

AbbrFile::usage = "AbbrFile is an option of MakeCode and specifies the
file in which the abbreviations were saved."

MatFile::usage = "MatFile is an option of MakeCode and specifies the file
in which the helicity matrix elements were saved (for processes with
external fermions)."

BornMask::usage = "BornMask is an option of MakeCode. It singles out the
code modules which contain Born amplitudes."

RenConst::usage = "RenConst is an option of MakeCode. It tells MakeCode
how the file containing the renormalization constants is called."

ProcessH::usage = "ProcessH is an option of MakeCode. It points to the
Fortran include file (included by num.F) which contains the definitions
for the process. This file is copied to process.h in the destination
directory so that changes can be made without overwriting the original."

RunF::usage = "RunF is an option of MakeCode. It points to the parameter
definition file for a run. This file is copied to run.F in the destination
directory so that changes can be made without overwriting the original."

NumF::usage = "NumF is an option of MakeCode. It points to the main
driver program, This file is copied to num.F in the destination directory
so that changes can be made without overwriting the original."

$NumPrepDir::usage = "$NumPrepDir is the path where NumPrep and its
companion files are located."

$GenerateCodeFor::usage = "$GenerateCodeFor specifies the platform for
which Fortran code is produced. This affects only the calling sequence for
the Fortran compiler, and is closely connected with the $F77 variable. If
you want the code to be produced always for the same architecture on which
NumPrep is running on, put $GenerateCodeFor = $SystemID."

$LoopToolsDir::usage = "$LoopToolsDir is the path where the include files
for LoopTools are located."

$RenConstDir::usage = "$RenConstDir is the path where the Fortran files 
for calculating the renormalization constants is located."

$BlockSize::usage = "$BlockSize gives the maximum LeafCount a Fortran
expression generated by NumPrep may have. Any expression with LeafCount >
$BlockSize will be chopped up before being written to the Fortran file. To
stay strictly within ANSI Fortran limits, $BlockSize would have to be
ridiculously low, say 100, but most Fortran compilers allow much larger
expressions."

$FileSize::usage = "$FileSize gives the maximum LeafCount the expressions
in a single Fortran file may have. If the expressions grow larger than
$FileSize, the file is split into several pieces."

$F77::usage = "$F77 specifies the command line for the Fortran compiler."

$IntArgFuncs = "$IntArgFuncs is a list of functions (typically Fortran
arrays) whose arguments must be integers."

reso::usage = "reso is a variable which is automatically substituted
for the propagator 1/(S - MH^2) in order to make treatment of the Higgs
resonance easier in Fortran."

resoT::usage = "resoT is a variable which is automatically substituted for
the propagator 1/(T - MH^2) in order to make treatment of the Higgs
resonance easier in Fortran."

resoU::usage = "resoU is a variable which is automatically substituted for
the propagator 1/(U - MH^2) in order to make treatment of the Higgs
resonance easier in Fortran."

coeff0::usage = "coeff0 is the array of the coefficients of the Born
matrix elements in Fortran."

coeff1::usage = "coeff1 is the array of the coefficients of the one-loop
matrix elements in Fortran."

dconjg::usage = "dconjg[x] is the complex conjugate of x in Fortran.
MakeCode replaces all Conjugate by dconjg."

Cval::usage = "Cval is the array containing the three-point integrals in
Fortran."

Dval::usage = "Dval is the array containing the four-point integrals in
Fortran."

SumOver::usage = "SumOver[i, r] indicates that the amplitude with which it
is multiplied is to be summed in the index i over the range r."


(* declare some FormCalc symbols and the fermion masses: *)

PrependTo[$ContextPath, "Parameters`"]

{ A0, B0, B1, B00, B11, DB0, DB1, DB00, DB11,
  C0i, Cget, D0i, Dget,
  DEN, S, T, U, e, k, s, Hel, Mat, Scale, MH2,
  dZfL1, dZfR1, dMf1,
  MLE, MQU, MQD,
  ME, ME2, MU, MU2, MD, MD2,
  MM, MM2, MC, MC2, MS, MS2,
  ML, ML2, MT, MT2, MB, MB2 }


Begin["`Private`"]

r8cmd = "!" <> $NumPrepDir <> "r8_" <> Environment["HOSTTYPE"] <> " > "

AppendTo[$ContextPath, "Parameters`"]

$NumberMarks = False

Off[FileDate::nffil]

DEN[S, MH2] = reso;
DEN[T, MH2] = resoT;
DEN[U, MH2] = resoU;
DEN[p_, m_] := (p - m)^-1

MLE2[1] = ME2; MLE2[2] = MM2; MLE2[3] = ML2;
MQU2[1] = MU2; MQU2[2] = MC2; MQU2[3] = MT2;
MQD2[1] = MD2; MQD2[2] = MS2; MQD2[3] = MB2

NN[x_] := N[x, 35] /. 0 -> 0.

Num[expr_] := NN[expr] /. {1. -> 1, -1. -> -1} /.
  rc:$IntArgFuncs[__] :> (rc /. r_Real :> Floor[r])


k[n_Integer] = n

s[n_Integer] := 2 + 3 n		(* the longitudinal polarization vector *)

e[n_Integer] := ToExpression["i" <> ToString[n]]

Hel[n_Integer] := ToExpression["i" <> ToString[n]]

A0[0] = 0

Derivative[1, 0, 0][B0] = DB0;
Derivative[1, 0, 0][B1] = DB1;
Derivative[1, 0, 0][B11] = DB11;
Derivative[1, 0, 0][B00] = DB00


ResoReplace[expr_] := expr /; FreeQ[expr, reso]

ResoReplace[expr_Times] :=
Block[ {stu, amp, yy, dsigma},
  amp = expr/reso;
  yy = amp /. U -> stu - S - T /. S -> MH2 /. stu -> S + T + U;
  yy *= $ModifyingFunction;
  If[ FreeQ[amp, reso],
    yy resoc + (amp - yy) reso,
  (* else *)
    dsigma = D[amp/reso, S] /. S -> MH2;
    dsigma *= $ModifyingFunction;
    dsigma resoc + (amp - yy - dsigma) reso
  ]
]

ResoReplace[plu_Plus] := ResoReplace/@ plu


Chunks[expr_, var_] :=
Block[ {theexpr = expr},
  If[ LeafCount[expr] > $BlockSize,
    If[ Head[expr] === Plus && !MemberQ[var, _Symbol],
      theexpr = List@@ expr /. Plus -> PlusChop;
      ChopUp[Plus@@ theexpr, var];
      Return[] ];
    theexpr = expr /. Plus -> PlusChop
  ];
  WriteString[hh, "\n\t", var//FortranForm, " = "];
  If[MatchQ[var, _coeff0 | _coeff1],
    WriteString[hh, var//FortranForm, " +\n     -  "] ];
  Write[hh, theexpr];
]


PlusChop[expr__] := ChopUp[Plus[expr], Unique["tmp"]] /;
  LeafCount[{expr}] > $BlockSize

PlusChop[expr__] := Plus[expr]

ChopUp[expr_, var_] :=
Block[ {i, l = ToString[var//FortranForm], $FileSize = $BlockSize},
  i = "\n\t" <> l <> " = ";
  l = i <> l <> " +\n     -  ";
  If[MatchQ[var, _coeff0 | _coeff1], i = l];
  Scan[(WriteString[hh, i]; Write[hh, #]; i = l)&,
    Flatten[CodeBlocks@@ expr]];
  var
]


CodeBlocks[a_, b_, r___] :=
  CodeBlocks[a + b, r] /; LeafCount[{a, b}] < $FileSize

CodeBlocks[a_, r___] := {a, CodeBlocks[r]}

CodeBlocks[] = Sequence[]


FortDecl[decl_, vars_] :=
Block[ {llen = Infinity, line = ""},
  Scan[
    ( l = StringLength[#] + 2;
      If[llen + l > 60,
        line = line <> decl <> #;
        llen = StringLength[decl],
      (* else *)
        line = line <> ", " <> #;
        llen += l ] )&,
    ToString[FortranForm[#]]&/@ vars ];
  WriteString[hh, line];
]


AddList[li_] :=
Block[ {r, j = 0},
  If[ li === {}, Return["0D0"] ];
  r = First[li] <> "()";
  Scan[
    ( r = r <> " + ";
      If[ StringLength[r] - j > 45,
        j = StringLength[r = r <> "\n     -    "] ];
      r = r <> # <> "()" )&,
    Rest[li]];
  r
]


OpenWriteFortran[file_] := OpenWrite[r8cmd <> file,
  FormatType -> FortranForm, PageWidth -> 67]


WriteVars[vars_, type_, common_] :=
Block[ {v, p},
  If[ Length[vars] =!= 0,
    v = Select[First/@ vars, StringTake[ToString[#], 1] =!= "t" &];
    p = Position[v, _[_Symbol..], 1, Heads -> False];
    FortDecl["\n\t" <> type, MapAt[IndexRange/@ # &, v, p]];
    FortDecl["\n\tcommon " <> common, MapAt[Head, v, p]];
    WriteString[hh, "\n"];
  ]
]


WriteAbbr[abbr_, subr_] :=
Block[ {thisdo = {}, lastdo = ""},
  WriteString[hh, "\tsubroutine ", subr, "\n"];
  If[ Length[abbr] =!= 0,
    WriteString[ hh,
      "\timplicit logical (a-s,u-z)\n",
      "\timplicit double complex (t)\n",
      "#include \"vars.h\"\n",
      "\tdouble complex Pair, Eps\n",
      "\texternal Pair, Eps\n",
      "\tdouble complex A0, B0, DB0, B1, DB1, B00, DB00, B11, DB11\n",
      "\texternal A0, B0, DB0, B1, DB1, B00, DB00, B11, DB11\n",
      "\tinteger Cget, Dget\n",
      "\texternal Cget, Dget\n\n"];
    Scan[
      ( If[ thisdo =!= #[[1]],
          WriteString[hh, lastdo, "\n"];
          WriteString[hh, "\tdo ", #, " = 1, ", IndexRange[#], "\n"]&/@
            (thisdo = #[[1]]);
          lastdo = StringJoin[Table["\tenddo\n", {Length[thisdo]}]] ];
        WriteString[hh, "\t", #[[2]]//FortranForm, " = "];
        Write[hh, #[[3]] ] )&,
      Sort[Apply[{Cases[#1, _Symbol], #1, #2}&, abbr, 1],
        OrderedQ[First/@ {##}]&] ];
    WriteString[hh, lastdo];
  ];
  WriteString[hh, "\tend\n\n"];
]


SumOver[index_, range_] := (
  IndexRange[index] = range;
  AppendTo[Indices[oname], index];
  1
)


WriteCode[indir_, outdir_][file_] :=
Block[ {oname, onamex, amp, hd},
  oname = StringReplace[file, {indir -> "", "/" -> "", ".m" -> ""}];
  Print["processing class ", oname];
  amp = Get[file];
  If[hreso, amp = ResoReplace[amp]];
  amp = Num[amp];
  amp = amp /. bca:(abfunc | C0i | D0i)[__] -> abr[bca];
  If[ Length[fabbr] =!= 0,
    hd = If[ StringMatchQ[oname, bornmask],
      amp = amp /. unused0 -> 0; coeff0,
      amp = amp /. unused1 -> 0; coeff1 ];
    amp = Collect[amp, fabbr]
  ];

  If[LeafCount[amp] > $FileSize && Head[amp] === Plus,
    MapIndexed[
      ( onamex = oname <> FromCharacterCode[#2[[1]] + 96];
        Indices[onamex] = Indices[oname];
        WriteFile[onamex, outdir, #1] )&,
      Flatten[CodeBlocks@@ amp]],
  (* else *)
    WriteFile[oname, outdir, amp] ];
]


WriteFile[oname_, outdir_, amp_] :=
Block[ {ofile, hh},
  AppendTo[procs, oname];
  Print["  writing ", ofile = outdir <> "/" <> oname <> ".F"];
  hh = OpenWriteFortran[ofile];
  If[ Length[fabbr] === 0,
    WriteString[hh,
      "#include \"defs.h\"\n\n",
      "\tdouble complex function ", oname, "()\n",
      "\timplicit logical (a-s,u-z)\n",
      "\timplicit double complex (t)\n",
      "\tinteger IndexDelta\n",
      "\texternal IndexDelta\n",
      "#include \"vars.h\"\n"];
    Chunks[amp, oname];
    WriteString[hh,
      "\n#ifdef DEBUG\n",
      "\tprint *, '", oname, " =',", oname,
      "\n#endif"],
  (* else *)
    WriteString[hh,
      "#include \"defs.h\"\n\n",
      "\tsubroutine ", oname, "\n",
      "\timplicit logical (a-s,u-z)\n",
      "\timplicit double complex (t)\n",
      "\tinteger IndexDelta\n",
      "\texternal IndexDelta\n",
      "#include \"vars.h\"\n"];
    WriteME/@ If[Head[amp] === Plus, amp, {amp}]
  ];
  WriteString[hh, "\n\tend\n"];
  Close[hh]
]


abfunc = A0 | B0 | B1 | B00 | B11 | DB0 | DB1 | DB00 | DB11

C0[args__] = C0i[cc0, args]

D0[args__] = D0i[dd0, args]

abr[ bca:abfunc[args__] ] :=
Block[ {uu = Unique["ab"]},
  in = Select[Indices[oname], !FreeQ[{args}, #]&];
  If[ Length[in] =!= 0, uu = uu@@ in ];
  cresolve[uu] = bca;
  abr[bca] = uu
]

abr[ C0i[i_, args__] ] :=
Block[ {uu = Unique["cd"]},
  in = Select[Indices[oname], !FreeQ[{args}, #]&];
  If[ Length[in] =!= 0, uu = uu@@ in ];
  iresolve[uu] = Cget[args]//Num;
  abr[C0i[id_, args]] = Cval[id, uu];
  Cval[i, uu]
]

abr[ D0i[i_, args__] ] :=
Block[ {uu = Unique["cd"]},
  in = Select[Indices[oname], !FreeQ[{args}, #]&];
  If[ Length[in] =!= 0, uu = uu@@ in ];
  iresolve[uu] = Dget[args]//Num;
  abr[D0i[id_, args]] = Dval[id, uu];
  Dval[i, uu]
]


MEtoNum[me_] := ToExpression[StringDrop[ToString[me], 1]]


Options[MakeCode] = {
  Resonance -> False,
  ModifyingFunction -> 1,
  Dyson -> False,
  AbbrFile -> "abbr",
  MatFile -> "mat",
  BornMask -> "born*",
  RenConst -> "rcsm_dimD.F",
  ProcessH -> $NumPrepDir <> "process.h_template",
  RunF -> $NumPrepDir <> "run.F_template",
  NumF -> $NumPrepDir <> "num.F"
}

MakeCode::selfdyson =
  "Warning: Applying Dyson summation to self energies!"

MakeCode[indir_, outdir_, mask_String:"*.m", opt___Rule] :=
Block[ {hreso, modifunc, dyson, abbr, mat, bornmask, rconst, processh,
runf, numf, i, j, hh, hd, procs, fprocs, bornprocs, cbca, ibca, Indices,
sums, oname, ofile, files, fabbr, WriteME, MEmax, ncoeff, nonzero,
unused0, unused1, Conjugate = dconjg},

  {hreso, modifunc, dyson, abbr, mat, bornmask,
    rconst, processh, runf, numf} =
    {Resonance, ModifyingFunction, Dyson, AbbrFile,
      MatFile, BornMask, RenConst, ProcessH, RunF, NumF} /.
      {opt} /. Options[MakeCode];

  files = DeleteCases[
    FileNames[Flatten[{mask, bornmask <> ".m"}], indir],
    abbr | mat ];
  If[ dyson && StringMatchQ[StringJoin[files], "*" <> indir <> "/self*"],
    Message[MakeCode::selfdyson] ];

  abbr = Get[indir <> "/" <> abbr];
  fabbr = First/@ Select[abbr, !FreeQ[#, NonCommutativeMultiply]&];
  abbr = Select[abbr, FreeQ[#, NonCommutativeMultiply]&];
  MEmax[_] = 0;

  WriteME[(me:Evaluate[Alternatives@@ fabbr]) coeff_] :=
  Block[ {n = MEtoNum[me],},
    MEmax[hd] = Max[MEmax[hd], n];
    Chunks[coeff, hd[n]]
  ];

  If[ FileType[ofile = indir <> "/" <> mat] === File,
    mat = Get[ofile];
    nonzero = First/@ DeleteCases[mat, _ -> 0];
    unused0 = Alternatives@@
      Select[ Union[#[[1, 2]]&/@ mat], FreeQ[nonzero, Mat[_, #]]& ];
    unused1 = Alternatives@@
      Select[ Union[#[[1, 1]]&/@ mat], FreeQ[nonzero, Mat[#, _]]& ];
    mat = Apply[(MEtoNum/@ #1) -> Num[#2] &, mat, 1]
  ];

  Indices[_] = {};

  procs = fprocs = {};
  Scan[WriteCode[indir, outdir], files];

  Print["writing ", ofile = outdir <> "/GNUmakefile"];
  hh = OpenWrite[ofile];
  WriteString[hh,
    "DIR = ", $NumPrepDir,
    "\nRCDIR = ", $RenConstDir,
    "\nLTDIR = ", $LoopToolsDir,
    "\nLIBS = -L$(LTDIR)$(HOSTTYPE) -lff",
    " -L$(CERN)/$(CERN_LEVEL)/lib -lpdflib -lmathlib -lpacklib",
    "\nFC = ", $F77, " -I. -I$(DIR) -I$(LTDIR)include -I$(RCDIR)",
      If[dyson, " -DDYSON", ""],
      " -g\nOBJS = abbr.o"];
  WriteString[hh, " \\\n ", #, ".o"]&/@ procs;
  WriteString[hh,
    "\n\ndefault: run\n\n",
    "renconst.o: $(RCDIR)", rconst, " $(DIR)kin.h\n",
    "\t$(FC) -c -o $@ $<\n\n",
    "$(OBJS): %.o: %.F $(DIR)kin.h vars.h\n",
    "\t$(FC) -c $< # -DDEBUG\n\n",
    "clean:\n",
    "\trm -f *.o\n\n",
    "%: %.F num.F $(LTDIR)include/tools.F $(DIR)kin.h ",
      "process.h feyn.F $(OBJS) renconst.o\n",
    "\t$(FC) -o $@ $< renconst.o $(OBJS) $(LIBS)\n\n"];
  Close[hh];

  Print["writing ", ofile = outdir <> "/vars.h"];
  hh = OpenWrite[ofile];
  WriteString[hh,
    "#include \"kin.h\"\n",
    "#include \"rcsm.h\"\n\n",
    "\tdouble complex Cval(13,1)\n",
    "\tcommon /cpave/ Cval\n\n",
    "\tdouble complex Dval(46,1)\n",
    "\tcommon /dpave/ Dval"];
  WriteVars[
    If[ FreeQ[abbr, Scale], abbr,
      WriteString[hh,
        "\n\tdouble precision Scale\n\tcommon /sme/ Scale\n"];
      DeleteCases[abbr, Scale -> _] ],
    "double complex ", "/sme/ "];
  cbca = Apply[#1[[1, 1]] -> #2 &, DownValues[cresolve], 1];
  WriteVars[cbca, "double complex ", "/bca/ "];
  ibca = Apply[#1[[1, 1]] -> #2 &, DownValues[iresolve], 1];
  WriteVars[ibca, "integer ", "/bca/ "];
  WriteVars[{#[[1, 1, 1]]}&/@ DownValues[IndexRange],
    "integer ", "/indices/ "];
  ncoeff = Max[MEmax[coeff0], MEmax[coeff1]];
  If[ MEmax[coeff0] =!= 0,
    WriteString[hh,
      "\n\tdouble complex coeff0(", MEmax[coeff0],
      "), coeff1(", Max[1, MEmax[coeff1]],
      ")\n\tdouble precision Mat(", ncoeff, ",", MEmax[coeff0],
      ")\n\tcommon /mat/ coeff0, coeff1, Mat\n"] ];
  Close[hh];

  Print["writing ", ofile = outdir <> "/abbr.F"];
  hh = OpenWriteFortran[ofile];
  WriteAbbr[Select[abbr, FreeQ[#, Plus]&]//ReleaseHold, "calc_sme"];
  WriteAbbr[Select[abbr, !FreeQ[#, Plus]&], "calc_abbr"];
  WriteAbbr[
    If[ Head[mat] =!= List, {},
      Select[ mat,
        #[[1, 1]] <= ncoeff && #[[1, 2]] <= MEmax[coeff0] & ] ],
    "calc_mat" ];

  cbca = Join[cbca, ibca];
  WriteAbbr[Select[cbca, FreeQ[#, T | U]&], "calc_bca"];
  WriteAbbr[Select[cbca, !FreeQ[#, T | U]&], "calc_bca2"];
  Close[hh];

  Print["writing ", ofile = outdir <> "/feyn.F"];
  hh = OpenWriteFortran[ofile];
  j = Plus@@ Cases[cbca, (v_ -> _Dget) :>
    Times@@ IndexRange/@ Cases[v, _Symbol]];
  i = Plus@@ Cases[cbca, (v_ -> _Cget) :>
    Times@@ IndexRange/@ Cases[v, _Symbol]];
  WriteString[hh,
    "*#define LAMBDA 1D10\n",
    "*#define MUDIM 1D10\n\n",
    "#define CSTORE ", 4 (i + 4 j) + 1,
    "\n#define DSTORE ", 4 j + 1, "\n",
    StringJoin[
      If[ NumberQ[ hd = NN[ToExpression[#]] ],
        {"#define ", #, " ", FortranForm[hd]//ToString, "\n"}, {} ]&/@
        Names["Parameters`*"] ] ];

  bornprocs = Select[procs, StringMatchQ[#, bornmask]&];
  procs = Complement[procs, bornprocs];
  If[ Length[procs] === 0,
    WriteString[hh, "\n#define oneloop() 0D0\n"],
  (* else *)
    sums[_] = {};
	(* make sure "oneloop" is initialized: *)
    sums[{}];
    AppendTo[sums[Indices[#]], #]&/@ procs;

    If[Length[fabbr] === 0,
      WriteString[hh,
        "\n\tdouble complex function oneloop()\n",
        "#include \"vars.h\"\n"];
      WriteString[hh, "\n\tdouble complex ", #,
        "\n\texternal ", #]&/@ procs;

      i = "\n\n\toneloop = ";
      Cases[DownValues[sums], (_[_[ind_List]] :> prc_) :>
        ( WriteString[hh, "\n\tdo ", #, " = 1, ",
            IndexRange[#]]&/@ ind;
          WriteString[hh, i, AddList[prc],
            StringJoin[Table["\n\tenddo", {Length[ind]}]]];
          i = "\n\toneloop = oneloop + "; )];
      WriteString[hh, "\n\tend\n"],

    (* else (fermionic subroutine) *)
      WriteString[hh, "\n\tdouble precision function oneloop()",
        "\n#include \"vars.h\"",
        "\n\tinteger i, j\n\tdouble complex me\n",
        "\n\tdo i = 1, ", MEmax[coeff1],
        "\n\t  coeff1(i) = dcmplx(0D0)",
        "\n\tenddo\n"];

      Cases[DownValues[sums], (_[_[ind_List]] :> prc_) :>
        ( WriteString[hh, "\n\tdo ", #, " = 1, ",
            IndexRange[#]]&/@ ind;
          WriteString[hh, "\n\tcall ", #]&/@ prc;
          WriteString[hh,
            StringJoin[Table["\n\tenddo", {Length[ind]}]]] )];

      WriteString[hh, "\n\n\tme = dcmplx(0d0)",
        "\n\tdo i = 1, ", MEmax[coeff1],
        "\n\t  do j = 1, ", MEmax[coeff0],
        "\n\t    me = me + coeff1(i)*dconjg(coeff0(j))*Mat(i,j)",
        "\n\t  enddo",
        "\n\tenddo",
        "\n\toneloop = 2D0*dble(me)",
        "\n\tend\n"]
    ];
  ];

  If[ Length[bornprocs] === 0,
    WriteString[hh, "\n#define born() 0D0\n"],
  (* else *)
    If[Length[fabbr] === 0,
      If[ Length[bornprocs] > 1,
        WriteString[hh, "\n#define BORN ",
          DeleteCases[bornprocs, "born"][[1]], "\n"] ],

    (* else (fermionic) *)
      WriteString[hh, "\n\tdouble precision function born()",
        "\n#include \"vars.h\"",
        "\n\tinteger i, j\n\tdouble complex me\n",
        "\n\tdo i = 1, ", MEmax[coeff0],
        "\n\t  coeff0(i) = dcmplx(0D0)",
        "\n\tenddo\n"];

      WriteString[hh, "\n\tcall ", #]&/@ bornprocs;

      WriteString[hh, "\n\n\tme = dcmplx(0d0)",
        "\n\tdo i = 1, ", MEmax[coeff0],
        "\n\t  do j = 1, ", MEmax[coeff0],
        "\n\t    me = me + coeff0(i)*dconjg(coeff0(j))*Mat(i,j)",
        "\n\t  enddo",
        "\n\tenddo",
        "\n\tborn = dble(me)"];
      WriteString[hh, "\n\tend\n"]
    ];
  ];
  Close[hh];
  CopyFile[processh, outdir <> "/process.h"];
  CopyFile[runf, outdir <> "/run.F"];
  CopyFile[numf, outdir <> "/num.F"];
]

End[]


$F77::undef = "Warning: I don't know the correct f77 compiler switches for
your system. I'll use f2c and proceed with fingers crossed. If I run into
problems, please update NumPrep.m."

(* IMPORTANT: you must choose here the correct compiler flags for your
   Fortran compiler, *in particular* (= at least) one to make the
   compiler disregard the stubborn 72-characters-per-line limit of
   Fortran. Practically all compilers have such a flag, only
   unfortunately, the naming of this flag varies widely across different
   computer systems.

   Choices for some systems are listed below in the $F77 = ... line. If
   you don't find your system among them, please look up the appropriate
   options in your f77 man page and insert them there. *)

$F77 := $F77 = Switch[ $GenerateCodeFor,
  "DEC-AXP", "f77 -O -extend_source -warn truncated_source",
  "HP-RISC", "fort77 -O2 +es +U77",
  "Solaris", "f77 -e",
  "PGF77",   "pgf77 -O2 -Mextend -g77libs",
  "Linux",   $NumPrepDir <> "f77c -O -f",
  _,         Message[f77::undef]; $NumPrepDir <> "f77c -O -f" ]

$GenerateCodeFor = "DEC-AXP"

$BlockSize = 700

$FileSize = 50 $BlockSize

$LoopToolsDir = HomeDirectory[] <> "/LoopTools/"

$RenConstDir = $NumPrepDir <> "rconst/fortran/"

	(* these functions must always have integer arguments *)
$IntArgFuncs = dZfL1 | dZfR1 | dMf1 | Af |
  MSf | MSf2 | MCha | MCha2 | MNeu | MNeu2 |
  USf | USfC | UCha | UChaC | VCha | VChaC | ZNeu | ZNeuC


EndPackage[]

