* main.F
* the main program for the Fortran code generated by FormCalc
* this file is part of FormCalc
* last modified 24 Jan 05 th


#define SCALAR 0
#define FERMION 1
#define PHOTON 2
#define GLUON PHOTON
#define VECTOR 3

* "real" data lines are tagged with this character:
#define TAG "|"

#include "process.h"

#ifdef BREMSSTRAHLUNG
#include "softphoton.F"
#endif


************************************************************************
** ParameterScan performs the actual calculation.  It scans over the
** parameter loops LOOP1..15 declared in run.F.

	integer function ParameterScan(dir, hel, avgfac,
     &    sqrtSfrom, sqrtSto, sqrtSstep,
     &    serialfrom, serialto, serialstep)
	implicit none
	character*(*) dir
	integer hel, serialfrom, serialto, serialstep
	double precision avgfac, sqrtSfrom, sqrtSto, sqrtSstep

#include "looptools.h"
#include "model.h"

	integer openlog
	external openlog

	integer serial
	double precision sqrtS

	call SetProcess(hel, avgfac, sqrtSfrom, sqrtSto)
	call ffini

	serial = 0
	ParameterScan = 0

	call ModelDefaults

	LOOP1
	LOOP2
	LOOP3
	LOOP4
	LOOP5
	LOOP6
	LOOP7
	LOOP8
	LOOP9
	LOOP10
	LOOP11
	LOOP12
	LOOP13
	LOOP14
	LOOP15

	serial = serial + 1
	if( serial .lt. serialfrom ) goto 1

	if( openlog(dir, serial) .eq. 0 ) then
	  call ModelConstIni(*3)

#ifdef MUDIM
	  call setmudim(dble(MUDIM))
#endif
#ifdef DELTA
	  call setdelta(dble(DELTA))
#endif
#ifdef LAMBDA
	  call setlambda(dble(LAMBDA))
#endif
	  Divergence = getdelta()

	  sqrtS = sqrtSfrom
	  call SetEnergy(sqrtS, *3)

	  call ModelDigest

100	  format(TAG, "# ", A, F10.4)
#define PRINT print 100,
	  PRINT1
	  PRINT2
	  PRINT3
	  PRINT4
	  PRINT5

	  ParameterScan = ParameterScan + 1

	  if( sqrtSto .eq. 0 ) then
	    call DoDifferential
	  else
2	    call DoIntegrated
	    if( sqrtS .lt. sqrtSto ) then
	      sqrtS = sqrtS + sqrtSstep
	      call SetEnergy(sqrtS, *3)
	      goto 2
	    endif
	  endif

101	  format(TAG/TAG/)
3	  print 101
	  call closelog
	endif

	serialfrom = serialfrom + serialstep
	if( serialfrom .gt. serialto ) goto 4

1	continue

4	call ffexi
	end


************************************************************************
** This is the main program.
** It scans the command line and then invokes ParameterScan.

	program main
	implicit none

	integer iargc, lnblnk, ParameterScan
	external iargc, lnblnk, ParameterScan

	double precision avgfac, sqrtSfrom, sqrtSto, sqrtSstep
	integer hel, serialfrom, serialto, serialstep
	integer argc, i, bits, c, df
	character*200 argv
	character*512 dir
	character*LEGS pol

	integer type(LEGS)
	data type /TYPES/

	argc = iargc()
	if( argc .lt. 2 .or. argc .gt. 3 ) goto 999

	call getarg(1, argv)
	if( lnblnk(argv) .ne. LEGS ) goto 999

	df = 2**LEGS

	do i = 1, LEGS
	  if( type(i) .eq. SCALAR ) then
	    c = ichar('S')
	    bits = 1
	    goto 1
	  endif

	  c = ichar(argv(i:i))
	  if( c .eq. ichar('+') ) then
	    bits = 4
	  else if( c .eq. ichar('-') ) then
	    bits = 1
	  else
	    c = iand(c, 223)
	    if( type(i) .eq. VECTOR ) then
	      if( c .eq. ichar('U') ) then
	        bits = 7
	      else if( c .eq. ichar('T') ) then
	        bits = 5
	      else if( c .eq. ichar('L') ) then
	        bits = 2
	      else
	        goto 998
	      endif
	    else
	      if( ior(c, 1) .ne. ichar('U') ) goto 998
	      c = ichar('U')
#ifdef DIRACFERMIONS
	      if( type(i) .eq. FERMION ) then
	        if( i .gt. LEGS_IN ) df = df/2
	        bits = 2
	        goto 1
	      endif
#endif
	      bits = 5
	    endif
	  endif

	  if( i .le. LEGS_IN ) df = df*(ibits(bits, 0, 1) +
     &      ibits(bits, 1, 1) + ibits(bits, 2, 1))

1	  pol(i:i) = char(c)
	  hel = hel*8 + bits
	enddo

	avgfac = 2**LEGS*dble(COLOURFACTOR)*dble(IDENTICALFACTOR)/df

	sqrtSfrom = 0
	sqrtSto = 0
	sqrtSstep = SQRTSSTEP
	call getarg(2, argv)
	read(argv, *, iostat=i, err=999)
     &    sqrtSfrom, sqrtSto, sqrtSstep

	serialfrom = 0
	serialto = 2**30
	serialstep = 1
	if( argc .gt. 2 ) then
	  call getarg(3, argv)
	  read(argv, *, iostat=i, err=999)
     &      serialfrom, serialto, serialstep
	endif

	call getarg(0, argv)
	i = lnblnk(argv)
	if( sqrtSto .eq. 0 ) then
100	  format(A, ".", A, ".", I5.5)
	  write(dir, 100) argv(1:i), pol, int(sqrtSfrom)
	else
101	  format(A, ".", A, ".", I5.5, "-", I5.5, ",", I5.5)
	  write(dir, 101) argv(1:i), pol,
     &      int(sqrtSfrom), int(sqrtSto), int(sqrtSstep)
	endif

	c = ParameterScan(dir, hel, avgfac,
     &    sqrtSfrom, sqrtSto, sqrtSstep,
     &    serialfrom, serialto, serialstep)

	if( c .eq. 0 ) then
	  c = 1
	else
	  c = 0
	endif
	call exit(c)

98	format ("Invalid polarization `", A, "' for leg ", I1)
998	print 98, argv(i:i), i
	stop

99      format (/"USAGE:  ", A, " p1...p", I1,
     &    " sqrtSfrom[,to[,step]] [serialfrom[,to[,step]]]"
     &    //"p1..", I1, " = +  for right-circular polarization"
     &    /"        -  for left-circular       ''"
     &    /"        l  for longitudinal        ''"
     &    /"        t  for transverse          ''"
     &    /"        u  for unpolarized particle"
     &    //"sqrtSfrom = compute the differential cross-section"
     &    /"sqrtSfrom,to,step = compute the total cross-section"
     &    //"serialfrom,to,step = range of serial numbers"/)

999	call getarg(0, argv)
	print 99, argv(1:lnblnk(argv)), LEGS, LEGS
	stop
	end

