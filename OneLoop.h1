* this is OneLoop.h1, the Form part of FormCalc
* last modified 4 Oct 99 th

* Note: this program is meant to run with Form 1. It is clearly
* inferior to the Form 2 code in OneLoop.h2 and is kept for
* compatibility reasons only. E.g. tensors are not generically
* reduced, and the algorithm gets pretty slow if spinor chains
* are involved.

.sort

s r2, CW, SW, C4, S4, C2, S2, EL, GS, a2, as2, unknown;
cf abb, Mat, fme, sun, DEN;
cf A0, B0m, B1m, B00m, B11m;
cf pave1, pave2, pave3, pave4, pave5;

.global

i J1, J2, J3, J4, C, IND1, IND2, IND3, IND4;
s M1, M2, M3, M4, X1, X2;
v P1, P2, P3;
f GA, ga2, fc, chp, ncm;
cf eq, neq, repl, hide, pivot, d0, c0, b0, a0, pv;
set bcd: b0, c0, d0;
set oma: omp, omm;
set opa: omm, omp;
set INDices: IND1, IND2, IND3, IND4;


#procedure TrivialSubst()
id r2^2 = 2;
id r2^-2 = 1/2;
id CW^-4 = C4;
id SW^-4 = S4;
id CW^-2 = C2;
id SW^-2 = S2;
id EL^4 = 16 * Pi^2 * a2;
id GS^4 = 16 * Pi^2 * as2;
#endprocedure


#call TrivialSubst{}

#call Mandelstam{}


#if 'ExtFermions' == 1

.sort

* Dirac algebra for open fermion chains:

#procedure DiracOrder()
  id ga(C?, P1?) * ga(C?, P1?) = P1.P1;
  repeat;
    id,once, ga(C?, P1?) = eq(P1, J4) * ga(C, J4);
    sum J4;
  endrepeat;
  repeat;
    label 0;
    id ga(C?, J1?) * ga(C?, J1?) = d_(J1, J1);
    id ga(C?, J1?) * ga(C?, J2?) = GA(C, J1, J2, J1, J2);
    symm GA 2, 3;
    id GA(C?, J1?, J2?, J1?, J2?) = ga(C, J1) * ga(C, J2);
    if( count(GA, 1) != 0 );
      id GA(C?, J2?, J1?, J1?, J2?) =
        2 * d_(J1, J2) - ga(C, J2) * ga(C, J1);
      id ga2(C?, J1?) = ga(C, J1);
      goto 0;
    endif;
    id,once, ga(C?, J1?) = ga2(C, J1);
  endrepeat;
  id ga2(C?, J1?) = ga(C, J1);
  id eq(P1?, J1?) = d_(P1, J1);
  id ga(C?, P1?) * ga(C?, P1?) = P1.P1;
#endprocedure

#procedure DoDiracEquation()
  repeat;
    id ga(C?, P1?) * Spinor(P1?, M1?, X1?) = X1 * M1 * Spinor(P1, M1, X1);
    id ga(C?, P1?) * ga(C?, J1?) * Spinor(P1?, M1?, X1?) =
      (2 * d_(P1, J1) - X1 * M1 * ga(C, J1)) * Spinor(P1, M1, X1);
    id ga(C?, P2?) * ga(C?, J1?) * pivot(C?, P1?, P2?) =
      (2 * d_(P2, J1) - ga(C, J1) * ga(C, P2)) * pivot(C, P1, P2);
  endrepeat;
  repeat;
* since we deal with helicity ME, there's always an omp or omm after the
* left spinor, that's why the immediate "Spinor pslash" is commented out:
*    id Spinor(P1?, M1?, X1?) * ga(C?, P1?) = X1 * M1 * Spinor(P1, M1, X1);
    id Spinor(P1?, M1?, X1?) * chp?oma?opa(C?) * ga(C?, P1?) =
      X1 * M1 * Spinor(P1, M1, X1) * chp(C);
    id Spinor(P1?, M1?, X1?) * chp?oma[X1](C?) * ga(C?, J1?) * ga(C?, P1?) =
      Spinor(P1, M1, X1) * (2 * d_(P1, J1) * oma[X1](C) -
        X1 * M1 * opa[X1](C) * ga(C, J1));
    id ga(C?, J2?) * ga(C?, P1?) * pivot(C?, P1?, P2?) =
      (2 * d_(P1, J2) - ga(C, P1) * ga(C, J2)) * pivot(C, P1, P2);
  endrepeat;
.sort
#call DiracOrder{}
.sort
#endprocedure

* this is a bad replacement for repeat...endrepeat which we can't
* use here since the .sorts inside DoDiracEquation are necessary
* to prevent workspace overflow
#procedure DiracEquation()
#call DoDiracEquation{}
#call DoDiracEquation{}
#endprocedure


repeat;
  id ga(C?, J1?) * chp?oma?opa(C?) = chp(C) * ga(C, J1);
  id omp(C?) * omm(C?) = 0;
  id omm(C?) * omp(C?) = 0;
  id omm(C?) * omm(C?) = omm(C);
  id omp(C?) * omp(C?) = omp(C);
endrepeat;
#call DiracOrder{}

id ga(C?, J1?) = fc(C, ga(C, J1));
id chp?oma(C?) = fc(C, chp(C));
repeat;
  id fc(C?, X1?) * fc(C?, X2?) = fc(C, X1 * X2);
endrepeat;
id fc(C?, chp?oma(C?)) = chp(C);
id Spinor(P1?, ?) * fc(C?, X1?) * Spinor(P2?, ??) =
  pivot(C, P1, P2) * Spinor(P1, .) * X1 * Spinor(P2, ..);
id fc(C?, X1?) = X1;

.sort

#call DiracSimplify{}
id chp?oma(C?) * Spinor(P2?, ?) * pivot(C?, P1?, P2?) =
  chp(C) * Spinor(P2, .);
id ga(C?, J1?) = g_(C, J1);

#endif

.sort

* cancel q^2's in the numerator

repeat;
  if( match(q1.q1) );
    id,once, q1.q1 * b0(P1?, M1?, ?) =
      repl(q1 - P1) * a0(.) + M1 * b0(P1, M1, .);
    id,once, q1.q1 * c0(P1?, P2?, M1?, M2?, M3?) =
      repl(q1 - P1) * b0(P2 - P1, M2, M3) +
        M1 * c0(P1, P2, M1, M2, M3);
    id,once, q1.q1 * d0(P1?, P2?, P3?, M1?, M2?, M3?, M4?) =
      repl(q1 - P1) * c0(P2 - P1, P3 - P1, M2, M3, M4) +
        M1 * d0(P1, P2, P3, M1, M2, M3, M4);
    if( count(repl, 1) > 0 );
      id q1 = eq(?);
      repeat;
        id eq(J1?) * repl(P1?) = d_(P1, J1) * repl(P1);
      endrepeat;
      id repl(?) = 1;
    endif;
  endif;
endrepeat;

.sort


id q1 = repl(?);
repeat;
  id repl(?) * repl(??) = repl(., ..);
endrepeat;
id repl(?) * pv?bcd(??) = pv(., ..);

#if 'DIM' == 4
* add local terms for dimred/CDR

id d0(J1?, J2?, J3?, J4?, P1?, P2?, P3?, M1?, M2?, M3?, M4?) =
  d0(J1, J2, J3, J4, P1, P2, P3, M1, M2, M3, M4) -
  eq(e_(J1, J2, J3, J4)) *
    5/144 * (d_(J1, J2) * d_(J3, J4) +
             d_(J1, J3) * d_(J2, J4) +
             d_(J1, J4) * d_(J2, J3)) +
  1/8 * (eq(J1, J2) * neq(J3, J4) + eq(J1, J3) * neq(J2, J4) +
         eq(J1, J4) * neq(J2, J3) + eq(J2, J3) * neq(J1, J4) +
         eq(J2, J4) * neq(J1, J3) + eq(J3, J4) * neq(J1, J2));

id eq(J1?, J1?) = 1;
id neq(J1?, J1?) = 0;
id neq(J1?, J2?) = d_(J1, J2);

id c0(J1?, J2?, J3?, P1?, P2?, M1?, M2?, M3?) =
  c0(J1, J2, J3, P1, P2, M1, M2, M3) +
  eq(e_(J1, J2, J3)) *
    1/36 * (d_(J1, J2) * (d_(P1, J3) + d_(P2, J3)) +
            d_(J1, J3) * (d_(P1, J2) + d_(P2, J2)) +
            d_(J2, J3) * (d_(P1, J1) + d_(P2, J1)));

id c0(J1?, J1?, P1?, P2?, M1?, M2?, M3?) =
  c0(J1, J1, P1, P2, M1, M2, M3) - 1/2;

id eq(0) = 1;
id eq(?) = 0;

id b0(J1?, J1?, P1?, M1?, M2?) = a0(M2) + M1 * b0(P1, M1, M2);

#endif


* decompose into Lorentz-covariant tensors:   

id d0(J1?, J2?, J3?, J4?, P1?, P2?, P3?, M1?, M2?, M3?, M4?) =
  pave4(0, 0, 0, 0, P1, P2, P3, M1, M2, M3, M4) *
     (d_(J1, J2) * d_(J3, J4) +
      d_(J1, J3) * d_(J2, J4) +
      d_(J1, J4) * d_(J2, J3))
#do i = 1, 3
#do j = 1, 3
  + pave4(0, 0, 'i', 'j', P1, P2, P3, M1, M2, M3, M4) *
     (d_(J1, J2) * d_(P'i', J3) * d_(P'j', J4) +
      d_(J2, J3) * d_(P'i', J1) * d_(P'j', J4) +
      d_(J1, J3) * d_(P'i', J2) * d_(P'j', J4) +
      d_(J1, J4) * d_(P'i', J2) * d_(P'j', J3) +
      d_(J2, J4) * d_(P'i', J1) * d_(P'j', J3) +
      d_(J3, J4) * d_(P'i', J1) * d_(P'j', J2))
#do k = 1, 3
#do l = 1, 3
  + pave4('i', 'j', 'k', 'l', P1, P2, P3, M1, M2, M3, M4) *
      d_(P'i', J1) * d_(P'j', J2) * d_(P'k', J3) * d_(P'l', J4)
#enddo
#enddo
#enddo
#enddo
  ;

id d0(J1?, J2?, J3?, P1?, P2?, P3?, M1?, M2?, M3?, M4?) =
#do i = 1, 3
  + pave4(0, 0, 'i', P1, P2, P3, M1, M2, M3, M4) *
     (d_(J1, J2) * d_(P'i', J3) +
      d_(J2, J3) * d_(P'i', J1) +
      d_(J1, J3) * d_(P'i', J2))
#do j = 1, 3
#do k = 1, 3
  + pave4('i', 'j', 'k', P1, P2, P3, M1, M2, M3, M4) *
      d_(P'i', J1) * d_(P'j', J2) * d_(P'k', J3)
#enddo
#enddo
#enddo
  ;

id d0(J1?, J2?, P1?, P2?, P3?, M1?, M2?, M3?, M4?) =
  pave4(0, 0, P1, P2, P3, M1, M2, M3, M4) * d_(J1, J2)
#do i = 1, 3
#do j = 1, 3
  + pave4('i', 'j', P1, P2, P3, M1, M2, M3, M4) *
      d_(P'i', J1) * d_(P'j', J2)
#enddo
#enddo
  ;

id d0(J1?, P1?, P2?, P3?, M1?, M2?, M3?, M4?) =
#do i = 1, 3
  + pave4('i', P1, P2, P3, M1, M2, M3, M4) * d_(P'i', J1)
#enddo
  ;

id c0(J1?, J2?, J3?, P1?, P2?, M1?, M2?, M3?) =
#do i = 1, 2
  + pave3(0, 0, 'i', P1, P2, M1, M2, M3) *
     (d_(J1, J2) * d_(P'i', J3) +
      d_(J2, J3) * d_(P'i', J1) +
      d_(J1, J3) * d_(P'i', J2))
#do j = 1, 2
#do k = 1, 2
  + pave3('i', 'j', 'k', P1, P2, M1, M2, M3) *
      d_(P'i', J1) * d_(P'j', J2) * d_(P'k', J3)
#enddo
#enddo
#enddo
  ;

id c0(J1?, J2?, P1?, P2?, M1?, M2?, M3?) =
  pave3(0, 0, P1, P2, M1, M2, M3) * d_(J1, J2)
#do i = 1, 2
#do j = 1, 2
  + pave3('i', 'j', P1, P2, M1, M2, M3) * d_(P'i', J1) * d_(P'j', J2)
#enddo
#enddo
  ;

id c0(J1?, P1?, P2?, M1?, M2?, M3?) =
#do i = 1, 2
  + pave3('i', P1, P2, M1, M2, M3) * d_(P'i', J1)
#enddo
  ;

id b0(J1?, J2?, P1?, M1?, M2?) =
  B00m(P1, M1, M2) * d_(J1, J2) +
  B11m(P1, M1, M2) * d_(P1, J1) * d_(P1, J2);

id b0(J1?, P1?, M1?, M2?) = B1m(P1, M1, M2) * d_(P1, J1);

symm pave4:11 1, 2, 3, 4;
symm pave4:10 1, 2, 3;
symm pave4:9 1, 2;
symm pave3:8 1, 2, 3;
symm pave3:7 1, 2;

id a0(0) = 0;
id a0(M1?) = A0(M1);
id b0(P1?, M1?, M2?) = B0m(P1, M1, M2);
symm B0m 2, 3;
id c0(P1?, P2?, M1?, M2?, M3?) = pave3(0, P1, P2, M1, M2, M3);
id d0(P1?, P2?, P3?, M1?, M2?, M3?, M4?) =
  pave4(0, P1, P2, P3, M1, M2, M3, M4);

id a0(?) = unknown;
id b0(?) = unknown;
id c0(?) = unknown;
id d0(?) = unknown;


#if 'ExtFermions' == 1

.sort

* Dirac algebra on open fermion chains again

id g_(C?, J1?) = ga(C, J1);
#call DiracOrder{}
#call DiracSimplify{}
id pivot(?) = 1;

#if 'DIM' == 4
* this is Chisholm's identity:
  repeat;
    id,once, ga(C?, J1?) * ga(C?, J2?) * ga(C?, J3?) =
      (omp(C) - omm(C)) * ga(C, J4) * e_(J1, J2, J3, J4) +
      d_(J1, J2) * ga(C, J3) -
      d_(J1, J3) * ga(C, J2) +
      d_(J2, J3) * ga(C, J1);
    sum J4;
  endrepeat;
  contract,0;
  repeat;
    id ga(C?, J1?) * chp?oma?opa(C?) = chp(C) * ga(C, J1);
    id omp(C?) * omm(C?) = 0;
    id omm(C?) * omp(C?) = 0;
    id omm(C?) * omm(C?) = omm(C);
    id omp(C?) * omp(C?) = omp(C);
  endrepeat;
#endif

id ga(C?, P1?) = fc(C, ga(P1));
#do i = 1, 4
  id,once, ga(C?, J1?) = fc(C, ga(IND'i')) * d_(J1, IND'i');
  id ga(C?, IND'i') = fc(C, ga(IND'i'));
  id d_(J1?, IND'i') = 1;
#enddo
#if 'VADecomp' == 1
  id omp(C?) = 1/2 + fc(C, ga5)/2;
  id omm(C?) = 1/2 - fc(C, ga5)/2;
#else
  id chp?oma(C?) = fc(C, chp);
#endif
repeat;
  id fc(C?, ?) * fc(C?, ??) = fc(C, ., ..);
endrepeat;

id e_(J1?, J2?, J3?, J4?INDices) =
  fme(e_(J1, J2, J3, J4));
id Spinor(?) * fc(C?, ??) * Spinor(???) =
  fme(ncm(Spinor(.), .., Spinor(...)));
id Spinor(?) * Spinor(??) = fme(ncm(Spinor(.), Spinor(..)));
id fc(C?, ?) = fme(ncm(.));
repeat;
  id fme(X1?) * fme(X2?) = fme(X1 * X2);
endrepeat;

#endif


#if 'SUNStuff' == 1

.sort
cf SUNT, SUNF, SUNFSum, SUND, PP;
set SUNobjs: SUNT, SUNF, SUNFSum, SUND;

repeat;
  id PP?SUNobjs(J1?, ?) * SumOver(J1?, ??) =
    PP(J1, .) * sun(SumOver(J1, ..));
  id PP?SUNobjs(J1?, J2?, ?) * SumOver(J2?, ??) =
    PP(J1, J2, .) * sun(SumOver(J2, ..));
  id PP?SUNobjs(J1?, J2?, J3?, ?) * SumOver(J3?, ??) =
    PP(J1, J2, J3, .) * sun(SumOver(J3, ..));
  id SUNFSum(J1?, J2?, J3?, J4?) * SumOver(J4?, ??) =
    SUNFSum(J1, J2, J3, J4) * sun(SumOver(J4, ..));
endrepeat;

id PP?SUNobjs(?) = sun(PP(.));

repeat;
  id sun(X1?) * sun(X2?) = sun(X1 * X2);
endrepeat;

#endif
  

.sort

#call DotSimplify{}

#if 'DIM' == 0
* add local terms for dimreg

repeat;
  id,once, D * A0(M1?) = 4 * A0(M1) - 2 * M1;
  id,once, D * B0m(?) = 4 * B0m(.) - 2;
  id,once, D * B11m(?) = 4 * B11m(.) - 2/3;
  id,once, D * B1m(?) = 4 * B1m(.) + 1;
  id,once, D * B00m(P1?, M1?, M2?) =
    4 * B00m(P1, M1, M2) + 1/6 * P1.P1 - 1/2 * M1 - 1/2 * M2;
  id,once, D * pave3(0, 0, P1?, P2?, M1?, M2?, M3?) =
    4 * pave3(0, 0, P1, P2, M1, M2, M3) - 1/2;
  id,once, D * pave3(J1?, 0, 0, P1?, P2?, M1?, M2?, M3?) =
    4 * pave3(J1, 0, 0, P1, P2, M1, M2, M3) + 1/6;
  id,once, D * pave4(0, 0, 0, 0, ?) = 4 * pave4(0, 0, 0, 0, .) - 1/12;
endrepeat;
id D = 4;

#endif

#call Mandelstam{}


* the Mat(...) are kept at the almost-outermost level (only SumOver
* comes before), i.e. the amplitude is of the form Sum[c[i] Mat[i], i]
* -> need this for the calculation of the squared amplitude

id fme(X1?) = Mat(fme(X1));
id sun(X1?) = Mat(sun(X1));

repeat;
  id Mat(X1?) * Mat(X2?) = Mat(X1 * X2);
endrepeat;

* in contrast, abb(...) remain at the innermost level because they'll
* be abbreviated anyway.

id P1? . P2? = abb(P1 . P2);
id e_(J1?, J2?, J3?, J4?) = abb(e_(J1, J2, J3, J4));

repeat;
  id abb(X1?) * abb(X2?) = abb(X1 * X2);
endrepeat;
