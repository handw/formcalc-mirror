* OneLoop.h1
* contains most simplifications done in FORM 1
* this file is part of FormCalc
* last modified 27 Apr 00 th

* Note: this program is meant to run with FORM 1. It is clearly
* inferior to the FORM 2 code in OneLoop.h2 and is kept for
* compatibility reasons only. E.g. tensors are not generically
* reduced, and the algorithm gets pretty slow if spinor chains
* are involved.

.sort

s sqrt2, CW, SW, CW2, SW2;
s EL, Alfa, Alfa2, GS, Alfas, Alfas2, unknown;
cf abb, Mat, Eps, fme, sun, IndexDelta, DEN, pave;
cf SUNT, SUNTSum, SUNF;

.global

i J1, J2, J3, J4, C, IND1, IND2, IND3, IND4;
s M1, M2, M3, M4, X1, X2;
v P1, P2, P3;
f GA, ga2, fc, chp, ncm;
cf eq, neq, repl, pivot, PP, a0, b0, c0, d0;
set paves: a0, b0, c0, d0;
set bcd: b0, c0, d0;
set oma: omp, omm;
set opa: omm, omp;
set INDices: IND1, IND2, IND3, IND4;


#procedure TrivialSubst()
id sqrt2^2 = 2;
id sqrt2^-2 = 1/2;
id CW^2 = CW2;
id CW^-2 = CW2^-1;
id SW^2 = SW2;
id SW^-2 = SW2^-1;
id EL^2 = 4*Pi*Alfa;
id Alfa^2 = Alfa2;
id GS^2 = 4*Pi*Alfas;
id Alfas^2 = Alfas2;
#endprocedure


#call TrivialSubst{}

#call Mandelstam{}


#if 'ExtFermions' == 1

.sort


* Dirac algebra for open fermion chains

#procedure DiracOrder()
  id ga(C?, P1?) * ga(C?, P1?) = P1.P1;
  repeat;
    id,once, ga(C?, P1?) = eq(P1, J4) * ga(C, J4);
    sum J4;
  endrepeat;
  repeat;
    label 0;
    id ga(C?, J1?) * ga(C?, J1?) = d_(J1, J1);
    id ga(C?, J1?) * ga(C?, J2?) = GA(C, J1, J2, J1, J2);
    symm GA 2, 3;
    id GA(C?, J1?, J2?, J1?, J2?) = ga(C, J1) * ga(C, J2);
    if( count(GA, 1) != 0 );
      id GA(C?, J2?, J1?, J1?, J2?) =
        2 * d_(J1, J2) - ga(C, J2) * ga(C, J1);
      id ga2(C?, J1?) = ga(C, J1);
      goto 0;
    endif;
    id,once, ga(C?, J1?) = ga2(C, J1);
  endrepeat;
  id ga2(C?, J1?) = ga(C, J1);
  id eq(P1?, J1?) = d_(P1, J1);
  id ga(C?, P1?) * ga(C?, P1?) = P1.P1;
#endprocedure


#procedure DoDiracEquation()
  repeat;
    id ga(C?, P1?) * Spinor(P1?, M1?, X1?) = X1*M1 * Spinor(P1, M1, X1);

    id ga(C?, P1?) * ga(C?, J1?) * Spinor(P1?, M1?, X1?) =
      (2*d_(P1, J1) - X1*M1 * ga(C, J1)) * Spinor(P1, M1, X1);

    id ga(C?, P2?) * ga(C?, J1?) * pivot(C?, P1?, P2?) =
      (2*d_(P2, J1) - ga(C, J1) * ga(C, P2)) * pivot(C, P1, P2);
  endrepeat;

  repeat;
* since we deal with helicity ME, there's always an omp or omm after the
* left spinor, that's why the immediate "Spinor pslash" is commented out:
*    id Spinor(P1?, M1?, X1?) * ga(C?, P1?) = X1 * M1 * Spinor(P1, M1, X1);

    id Spinor(P1?, M1?, X1?) * chp?oma?opa(C?) * ga(C?, P1?) =
      X1 * M1 * Spinor(P1, M1, X1) * chp(C);

    id Spinor(P1?, M1?, X1?) * chp?oma[X2](C?) * ga(C?, J1?) * ga(C?, P1?) =
      Spinor(P1, M1, X1) *
        (2*d_(P1, J1) * oma[X2](C) - X1*M1 * opa[X2](C) * ga(C, J1));

    id ga(C?, J2?) * ga(C?, P1?) * pivot(C?, P1?, P2?) =
      (2*d_(P1, J2) - ga(C, P1) * ga(C, J2)) * pivot(C, P1, P2);
  endrepeat;
.sort
#call DiracOrder{}
.sort
#endprocedure


* this is a bad replacement for repeat...endrepeat which we can't
* use here since the .sorts inside DoDiracEquation are necessary
* to prevent workspace overflow

#procedure DiracEquation()
#call DoDiracEquation{}
#call DoDiracEquation{}
#endprocedure


repeat;
  id ga(C?, J1?) * chp?oma?opa(C?) = chp(C) * ga(C, J1);
  id omp(C?) * omm(C?) = 0;
  id omm(C?) * omp(C?) = 0;
  id omm(C?) * omm(C?) = omm(C);
  id omp(C?) * omp(C?) = omp(C);
endrepeat;
#call DiracOrder{}

id ga(C?, J1?) = fc(C, ga(C, J1));
id chp?oma(C?) = fc(C, chp(C));
repeat;
  id fc(C?, X1?) * fc(C?, X2?) = fc(C, X1 * X2);
endrepeat;
id fc(C?, chp?oma(C?)) = chp(C);
id Spinor(P1?, ?) * fc(C?, X1?) * Spinor(P2?, ??) =
  pivot(C, P1, P2) * Spinor(P1, .) * X1 * Spinor(P2, ..);
id fc(C?, X1?) = X1;

.sort

#call DiracSimplify{}
id chp?oma(C?) * Spinor(P2?, ?) * pivot(C?, P1?, P2?) =
  chp(C) * Spinor(P2, .);
id ga(C?, J1?) = g_(C, J1);

#endif

.sort


* cancel q^2's in the numerator

repeat;
  if( match(q1.q1) );
    id,once, q1.q1 * b0(P1?, M1?, ?) =
      repl(q1 - P1) * a0(.) + M1 * b0(P1, M1, .);
    id,once, q1.q1 * c0(P1?, P2?, M1?, M2?, M3?) =
      repl(q1 - P1) * b0(P2 - P1, M2, M3) +
        M1 * c0(P1, P2, M1, M2, M3);
    id,once, q1.q1 * d0(P1?, P2?, P3?, M1?, M2?, M3?, M4?) =
      repl(q1 - P1) * c0(P2 - P1, P3 - P1, M2, M3, M4) +
        M1 * d0(P1, P2, P3, M1, M2, M3, M4);
    if( count(repl, 1) > 0 );
      id q1 = eq(?);
      repeat;
        id eq(J1?) * repl(P1?) = d_(P1, J1) * repl(P1);
      endrepeat;
      id repl(?) = 1;
    endif;
  endif;
endrepeat;

.sort


id q1 = pave(?);
repeat;
  id pave(?) * pave(??) = pave(., ..);
endrepeat;
id pave(?) * PP?paves(??) = PP(., ..);

#if 'DIM' == 4
* add local terms for dimred/CDR

id d0(J1?, J2?, J3?, J4?, P1?, P2?, P3?, M1?, M2?, M3?, M4?) =
  d0(J1, J2, J3, J4, P1, P2, P3, M1, M2, M3, M4) -
  eq(e_(J1, J2, J3, J4)) *
    5/144 * (d_(J1, J2) * d_(J3, J4) +
             d_(J1, J3) * d_(J2, J4) +
             d_(J1, J4) * d_(J2, J3)) +
  1/8 * (eq(J1, J2) * neq(J3, J4) + eq(J1, J3) * neq(J2, J4) +
         eq(J1, J4) * neq(J2, J3) + eq(J2, J3) * neq(J1, J4) +
         eq(J2, J4) * neq(J1, J3) + eq(J3, J4) * neq(J1, J2));

id eq(J1?, J1?) = 1;
id neq(J1?, J1?) = 0;
id neq(J1?, J2?) = d_(J1, J2);

id c0(J1?, J2?, J3?, P1?, P2?, M1?, M2?, M3?) =
  c0(J1, J2, J3, P1, P2, M1, M2, M3) +
  eq(e_(J1, J2, J3)) *
    1/36 * (d_(J1, J2) * (d_(P1, J3) + d_(P2, J3)) +
            d_(J1, J3) * (d_(P1, J2) + d_(P2, J2)) +
            d_(J2, J3) * (d_(P1, J1) + d_(P2, J1)));

id c0(J1?, J1?, P1?, P2?, M1?, M2?, M3?) =
  c0(J1, J1, P1, P2, M1, M2, M3) - 1/2;

id eq(0) = 1;
id eq(?) = 0;

id b0(J1?, J1?, P1?, M1?, M2?) = a0(M2) + M1*b0(P1, M1, M2);

#endif


* decompose into Lorentz-covariant tensors

id d0(J1?, J2?, J3?, J4?, P1?, P2?, P3?, M1?, M2?, M3?, M4?) =
  d0(P1, P2, P3, M1, M2, M3, M4) * (
    pave(0,0,0,0) *
     (d_(J1, J2) * d_(J3, J4) +
      d_(J1, J3) * d_(J2, J4) +
      d_(J1, J4) * d_(J2, J3))
#do i = 1, 3
#do j = 1, 3
  + pave(0,0,'i','j') *
     (d_(J1, J2) * d_(P'i', J3) * d_(P'j', J4) +
      d_(J2, J3) * d_(P'i', J1) * d_(P'j', J4) +
      d_(J1, J3) * d_(P'i', J2) * d_(P'j', J4) +
      d_(J1, J4) * d_(P'i', J2) * d_(P'j', J3) +
      d_(J2, J4) * d_(P'i', J1) * d_(P'j', J3) +
      d_(J3, J4) * d_(P'i', J1) * d_(P'j', J2))
#do k = 1, 3
#do l = 1, 3
  + pave('i','j','k','l') *
      d_(P'i', J1) * d_(P'j', J2) * d_(P'k', J3) * d_(P'l', J4)
#enddo
#enddo
#enddo
#enddo
  );

id d0(J1?, J2?, J3?, P1?, P2?, P3?, M1?, M2?, M3?, M4?) =
  d0(P1, P2, P3, M1, M2, M3, M4) * (
#do i = 1, 3
  + pave(0,0,'i') *
     (d_(J1, J2) * d_(P'i', J3) +
      d_(J2, J3) * d_(P'i', J1) +
      d_(J1, J3) * d_(P'i', J2))
#do j = 1, 3
#do k = 1, 3
  + pave('i','j','k') * d_(P'i', J1) * d_(P'j', J2) * d_(P'k', J3)
#enddo
#enddo
#enddo
  );

id d0(J1?, J2?, P1?, P2?, P3?, M1?, M2?, M3?, M4?) =
  d0(P1, P2, P3, M1, M2, M3, M4) * (
    pave(0,0) * d_(J1, J2)
#do i = 1, 3
#do j = 1, 3
  + pave('i','j') * d_(P'i', J1) * d_(P'j', J2)
#enddo
#enddo
  );

id d0(J1?, P1?, P2?, P3?, M1?, M2?, M3?, M4?) =
  d0(P1, P2, P3, M1, M2, M3, M4) * (
#do i = 1, 3
  + pave('i') * d_(P'i', J1)
#enddo
  );

id c0(J1?, J2?, J3?, P1?, P2?, M1?, M2?, M3?) =
  c0(P1, P2, M1, M2, M3) * (
#do i = 1, 2
  + pave(0,0,'i') *
     (d_(J1, J2) * d_(P'i', J3) +
      d_(J2, J3) * d_(P'i', J1) +
      d_(J1, J3) * d_(P'i', J2))
#do j = 1, 2
#do k = 1, 2
  + pave('i','j','k') * d_(P'i', J1) * d_(P'j', J2) * d_(P'k', J3)
#enddo
#enddo
#enddo
  );

id c0(J1?, J2?, P1?, P2?, M1?, M2?, M3?) =
  c0(P1, P2, M1, M2, M3) * (
    pave(0,0) * d_(J1, J2)
#do i = 1, 2
#do j = 1, 2
  + pave('i','j') * d_(P'i', J1) * d_(P'j', J2)
#enddo
#enddo
  );

id c0(J1?, P1?, P2?, M1?, M2?, M3?) =
  c0(P1, P2, M1, M2, M3) * (
#do i = 1, 2
  + pave('i') * d_(P'i', J1)
#enddo
  );

id b0(J1?, J2?, P1?, M1?, M2?) =
  b0(P1, M1, M2) * (
    pave(0,0) * d_(J1, J2)
  + pave(1,1) * d_(P1, J1) * d_(P1, J2)
  );

id b0(J1?, P1?, M1?, M2?) = b0(P1, M1, M2) * pave(1) * d_(P1, J1);

symm pave;

if(count(pave, 1) == 0);
  symm b0 2, 3;
  id PP?paves(?) = pave(PP(0), .);
else;
  repeat;
    id pave(?) * pave(??) = pave(., ..);
  endrepeat;
  id pave(??) * PP?paves(?) = pave(PP(..), .);
endif;

id a0(?) = unknown;
id b0(?) = unknown;
id c0(?) = unknown;
id d0(?) = unknown;


#if 'ExtFermions' == 1

.sort

* Dirac algebra on open fermion chains again

id g_(C?, J1?) = ga(C, J1);
#call DiracOrder{}
#call DiracSimplify{}
id pivot(?) = 1;

#if 'DIM' == 4
* this is Chisholm's identity:
  repeat;
    id,once, ga(C?, J1?) * ga(C?, J2?) * ga(C?, J3?) =
      (omp(C) - omm(C)) * ga(C, J4) * e_(J1, J2, J3, J4) +
      d_(J1, J2) * ga(C, J3) -
      d_(J1, J3) * ga(C, J2) +
      d_(J2, J3) * ga(C, J1);
    sum J4;
  endrepeat;
  contract,0;
  repeat;
    id ga(C?, J1?) * chp?oma?opa(C?) = chp(C) * ga(C, J1);
    id omp(C?) * omm(C?) = 0;
    id omm(C?) * omp(C?) = 0;
    id omm(C?) * omm(C?) = omm(C);
    id omp(C?) * omp(C?) = omp(C);
  endrepeat;
#endif

id ga(C?, P1?) = fc(C, ga(P1));
#do i = 1, 4
  id,once, ga(C?, J1?) = fc(C, ga(IND'i')) * d_(J1, IND'i');
  id ga(C?, IND'i') = fc(C, ga(IND'i'));
  id d_(J1?, IND'i') = 1;
#enddo
#if 'VADecomp' == 1
  id omp(C?) = 1/2 + fc(C, ga5)/2;
  id omm(C?) = 1/2 - fc(C, ga5)/2;
#else
  id chp?oma(C?) = fc(C, chp);
#endif
repeat;
  id fc(C?, ?) * fc(C?, ??) = fc(C, ., ..);
endrepeat;

id e_(J1?, J2?, J3?, J4?INDices) =
  fme(Eps(J1, J2, J3, J4));
id Spinor(?) * fc(C?, ??) * Spinor(???) =
  fme(ncm(Spinor(.), .., Spinor(...)));
id Spinor(?) * Spinor(??) = fme(ncm(Spinor(.), Spinor(..)));
id fc(C?, ?) = fme(ncm(.));
repeat;
  id fme(X1?) * fme(X2?) = fme(X1 * X2);
endrepeat;

#endif

.sort


#call DotSimplify{}

#if 'DIM' == 0
* add local terms for dimreg

repeat;
  id,once, D*pave(a0(0), M1?) = 4*pave(a0(0), M1) - 2*M1;
  id,once, D*pave(b0(0), ?) = 4*pave(b0(0), .) - 2;
  id,once, D*pave(b0(1), ?) = 4*pave(b0(1), .) + 1;
  id,once, D*pave(b0(0,0), P1?, M1?, M2?) =
    4*pave(b0(0,0), P1, M1, M2) + P1.P1/6 - M1/2 - M2/2;
  id,once, D*pave(b0(1,1), ?) = 4*pave(b0(1,1), .) - 2/3;
  id,once, D*pave(c0(0,0), ?) = 4*pave(c0(0,0), .) - 1/2;
  id,once, D*pave(c0(1,0,0), ?) = 4*pave(c0(0,0,1), .) + 1/6;
  id,once, D*pave(c0(2,0,0), ?) = 4*pave(c0(0,0,2), .) + 1/6;
  id,once, D*pave(d0(0,0,0,0), ?) = 4*pave(d0(0,0,0,0), .) - 1/12;
endrepeat;
id D = 4;

#endif

#call Mandelstam{}


* the Mat(...) are kept at the almost-outermost level (only SumOver
* comes before), i.e. the amplitude is of the form Sum[c[i] Mat[i], i]
* -> need this for the calculation of the squared amplitude

id fme(X1?) = Mat(fme(X1));

* in contrast, abb(...) remain at the innermost level because they'll
* be abbreviated anyway.

id P1? . P2? = abb(P1 . P2);
id e_(J1?, J2?, J3?, J4?) = abb(e_(J1, J2, J3, J4));

repeat;
  id abb(X1?) * abb(X2?) = abb(X1 * X2);
endrepeat;

